# Shaman AI Agent Coordination Framework

## 1. Overview & Philosophy

Shaman is a comprehensive, enterprise-grade backend framework designed to be the central orchestration hub in a federated agent ecosystem. It serves simultaneously as:

- **Git-Based Agent Platform:** A robust platform for managing AI agents as code through git repositories, enabling version control, collaboration, and deployment workflows.
- **A2A Gateway:** A fully compliant Agent2Agent (A2A) protocol implementation that can both expose internal git-based agents and consume external A2A agents.
- **Enterprise Control Plane:** A manageable, observable, and scalable system with git synchronization, permissions, and comprehensive audit trails.

### Core Principles:

- **Agents as Code:** AI agents are defined in git repositories as markdown files with frontmatter, enabling familiar development workflows.
- **Protocol Interoperability:** Native support for MCP (Model Context Protocol) and A2A (Agent2Agent) standards.
- **Bidirectional Federation:** Internal git-based agents can be exposed via A2A while consuming external A2A agents seamlessly.
- **Dynamic Execution:** Workflows unfold dynamically based on agent decisions, forming complex DAGs at runtime.
- **Pluggable Infrastructure:** All critical components (workflow engines, providers, storage) are swappable via adapter patterns.
- **Observable by Design:** OpenTelemetry-first architecture with structured logging and comprehensive metrics.
- **Enterprise-Ready:** Built-in support for git synchronization, agent namespacing, authentication, authorization, and audit trails.
- **Explicit Agent Completion:** Agents explicitly signal completion using standardized tools, enabling reliable parent-child coordination.
- **Unified Tool/Agent Interface:** Agents call both tools and other agents through the same mechanism, providing a consistent programming model.

## 2. Comprehensive Concepts & Terminology

### 2.1 Core Entities

- **Provider:** A configured LLM service endpoint (OpenAI, Anthropic, Groq, local Ollama). Defined statically in configuration with connection details and authentication credentials.

- **Agent Repository:** A git repository containing agent definitions as markdown files with frontmatter. Repositories can be root (unnamespaced) or namespaced.

- **Agent Definition:** A markdown file with YAML frontmatter containing agent configuration (name, description, model, permissions) and a prompt template.

- **Directory:** A hierarchical organizational structure within git repositories, enabling nested folder navigation (e.g., `/sales/pr-agent`, `/support/billing-agent`).

- **Tag:** A keyword-based classification system defined in agent frontmatter, supporting discovery and categorization.

- **MCP Server:** A service exposing tools via the Model Context Protocol. Can be:

  - `STDIO`: Local processes (defined in config)
  - `HTTP`: Remote HTTP endpoints (API-managed)
  - `A2A`: External A2A-compliant agents (API-managed)

- **Tool:** A function exposed by an MCP Server, with JSON Schema definition, usage statistics, and permission controls.

- **External A2A Agent:** An agent from an external system that implements the A2A protocol, registered in Shaman for consumption by internal agents.

### 2.2 Execution Entities

- **Run:** Top-level execution instance with unique ID, representing a complete user request fulfillment.

- **Step:** Single agent execution within a Run, containing:

  - Complete conversation history
  - Token usage and cost tracking
  - Execution timeline
  - Parent-child relationships (forms the DAG)
  - Git version reference for traceability

- **Memory:** Persistent data saved by agents, with:

  - Structured key-value storage
  - Cross-run accessibility
  - Namespace isolation by agent
  - Expiration policies

- **Message:** Individual conversation turn with role-based typing and extensible part system.

- **Stream Chunk:** Real-time execution events pushed via WebSocket subscriptions.

- **Input Request:** User input requirements generated by agents using the `request_user_input` tool, stored with context for later resolution.

### 2.3 Agent Management Model

#### 2.3.1 Git-Based Agent Definitions

Agents are defined as markdown files with YAML frontmatter in git repositories:

```markdown
---
name: "CustomerSupportAgent"
description: "Handles customer inquiries about orders, returns, and account issues"
version: "2.1.0"
tags: ["customer-support", "tier-1", "orders"]
model: "gpt-4-turbo"
providers: ["openai_gpt4"]
mcpServers: ["order-management", "customer-db", "refund-processor"]
allowedAgents: ["BillingSpecialist", "EscalationManager"]
examples:
  - "Help customer with order status inquiry"
  - "Process return request for damaged item"
---

You are a Tier 1 Customer Support Agent for an e-commerce platform...

## Available Tools

Your tools will be automatically injected based on configured MCP servers.

## Available Agents

You can delegate to: {{allowed_agents}}

Your task: {{prompt}}
```

#### 2.3.2 Repository Structure and Namespacing

```
Root Repository (unnamespaced):
main-agents/
├── sales/pr-agent/prompt.md          → "sales/pr-agent"
├── support/billing-agent/prompt.md   → "support/billing-agent"
└── public/demo-agent/prompt.md       → "public/demo-agent"

Namespaced Repository:
experimental-agents/
├── nlp/sentiment/prompt.md           → "experimental/nlp/sentiment"
└── vision/object-detect/prompt.md    → "experimental/vision/object-detect"
```

#### 2.3.3 Agent Resolution Strategy

1. **Root Repository Lookup:** Check unnamespaced agents first
2. **Namespaced Repository Lookup:** Parse namespace and check specific repository
3. **External A2A Lookup:** Check registered external A2A agents
4. **Error:** Agent not found

#### 2.3.4 Explicit Completion Model

All agent-to-agent calls use **explicit completion**, where child agents must call a `complete_agent_execution` tool to signal task completion. This provides:

- **Clear Completion Semantics:** Parent agents know definitively when children are done
- **Structured Results:** Rich completion information including status, confidence, and metadata
- **Partial Completion Support:** Agents can signal partial completion when blocked or uncertain
- **Parent Coordination:** Parents wait for explicit completion before proceeding

### 2.4 Standard System Tools

All agents have automatic access to these system tools:

#### 2.4.1 Agent Coordination Tools

```typescript
interface AgentCoordinationTools {
  call_agent: {
    name: "call_agent";
    description: "Delegate a task to another specialized agent (internal or external)";
    schema: {
      type: "object";
      properties: {
        agent_name: {
          type: "string";
          description: "Name of agent to call (e.g., 'sales/pr-agent', 'external/legal-expert')";
        };
        input: {
          type: "string";
          description: "Task description for the agent";
        };
        context_scope: {
          type: "string";
          enum: ["FULL", "NONE", "SPECIFIC"];
          default: "FULL";
          description: "How much context to share with child agent";
        };
      };
      required: ["agent_name", "input"];
    };
  };

  complete_agent_execution: {
    name: "complete_agent_execution";
    description: "Signal completion of agent task - REQUIRED to finish execution";
    schema: {
      type: "object";
      properties: {
        result: { type: "string"; description: "Final result of the task" };
        status: {
          type: "string";
          enum: ["SUCCESS", "PARTIAL", "FAILED"];
          description: "Completion status";
        };
        confidence: {
          type: "number";
          minimum: 0;
          maximum: 1;
          description: "Confidence in the result (0-1)";
        };
        requiresFollowup: {
          type: "boolean";
          default: false;
          description: "Whether this task needs additional work";
        };
        metadata: {
          type: "object";
          description: "Additional structured data about the completion";
        };
      };
      required: ["result", "status"];
    };
  };
}
```

#### 2.4.2 User Interaction Tools

```typescript
interface UserInteractionTools {
  request_user_input: {
    name: "request_user_input";
    description: "Request input from user - pauses execution until response received";
    schema: {
      type: "object";
      properties: {
        prompt: {
          type: "string";
          description: "Question or prompt to show the user";
        };
        inputType: {
          type: "string";
          enum: ["text", "choice", "file", "approval"];
          default: "text";
          description: "Type of input expected";
        };
        choices: {
          type: "array";
          items: { type: "string" };
          description: "Available choices if inputType is 'choice'";
        };
        required: {
          type: "boolean";
          default: true;
          description: "Whether input is required to continue";
        };
        timeoutMinutes: {
          type: "number";
          default: 1440;
          description: "Minutes to wait before timing out";
        };
      };
      required: ["prompt"];
    };
  };
}
```

#### 2.4.3 Memory Management Tools

```typescript
interface MemoryManagementTools {
  save_memory: {
    name: "save_memory";
    description: "Save data for later retrieval across runs";
    schema: {
      type: "object";
      properties: {
        key: { type: "string"; description: "Unique identifier for the data" };
        value: { type: "object"; description: "Data to save (any JSON value)" };
        expiresAt: {
          type: "string";
          format: "date-time";
          description: "Optional expiration time";
        };
      };
      required: ["key", "value"];
    };
  };

  load_memory: {
    name: "load_memory";
    description: "Retrieve previously saved data";
    schema: {
      type: "object";
      properties: {
        key: { type: "string"; description: "Identifier of data to retrieve" };
      };
      required: ["key"];
    };
  };
}
```

## 3. Use Cases & Application Scenarios

### 3.1 Enterprise Customer Support Automation

**Scenario:** A large e-commerce company wants to automate customer support inquiries while maintaining human oversight for complex issues.

**Git Repository Structure:**

```
main-agents/
├── support/tier1-agent/prompt.md
├── support/billing-specialist/prompt.md
└── support/escalation-manager/prompt.md
```

**Agent Definition (support/tier1-agent/prompt.md):**

````markdown
---
name: "Tier1CustomerSupport"
description: "Handles common customer inquiries about orders, returns, and account issues"
version: "2.1.0"
tags: ["customer-support", "tier-1", "e-commerce"]
model: "gpt-4-turbo"
providers: ["openai_gpt4"]
mcpServers: ["order-management", "customer-db", "refund-processor"]
allowedAgents: ["support/billing-specialist", "support/escalation-manager"]
examples:
  - "Customer wants to check order status"
  - "Process return for damaged product"
  - "Help with billing inquiry"
---

You are a Tier 1 Customer Support Agent for an e-commerce platform. Your role is to help customers with their inquiries efficiently and escalate complex issues when needed.

## Available Tools

You have access to these tools:

- **order_lookup**: Search for customer orders by ID or customer info
- **customer_profile**: Get customer account details and history
- **refund_processor**: Process standard refunds within policy

## Available Agents

You can delegate to these specialists:

- **support/billing-specialist**: For complex billing issues, payment problems, or policy exceptions
- **support/escalation-manager**: For VIP customers or sensitive complaints

## Agent Calling Examples

To delegate a billing issue:

```json
{
  "tool_calls": [
    {
      "id": "call_billing",
      "type": "function",
      "function": {
        "name": "call_agent",
        "arguments": "{\"agent_name\": \"support/billing-specialist\", \"input\": \"Customer wants refund for 95-day-old order but is VIP with $50K annual spend\"}"
      }
    }
  ]
}
```
````

## Completion Requirement

You MUST complete your work by calling:

```json
{
  "tool_calls": [
    {
      "id": "complete",
      "type": "function",
      "function": {
        "name": "complete_agent_execution",
        "arguments": "{\"result\": \"Your summary of actions taken\", \"status\": \"SUCCESS\", \"confidence\": 0.9}"
      }
    }
  ]
}
```

Your task: {{prompt}}

```

**Execution Flow:**
```

Customer: "I want to cancel order #ORDER-789 and get a refund"

1. Tier1Agent calls order_lookup tool:
   → Gets order details: $299, placed 95 days ago

2. Tier1Agent calls customer_profile tool:  
   → Customer is VIP with $50K annual spend

3. Tier1Agent recognizes policy exception needed, calls agent:
   {
   "name": "call_agent",
   "arguments": {
   "agent_name": "support/billing-specialist",
   "input": "VIP customer John Smith wants refund for order #ORDER-789. Order is 95 days old (exceeds 90-day policy) but customer has $50K annual spend. Please evaluate exception."
   }
   }

4. BillingSpecialist analyzes case, requests approval:
   {
   "name": "request_user_input",
   "arguments": {
   "prompt": "Customer exceeds refund policy but is VIP. Approve exception?",
   "inputType": "choice",
   "choices": ["Approve full refund", "Offer store credit", "Deny exception"]
   }
   }

5. Human responds: "Approve full refund"

6. BillingSpecialist processes refund and completes:
   {
   "name": "complete_agent_execution",
   "arguments": {
   "result": "Full refund of $299.99 approved and processed. Refund ID: REF-456789",
   "status": "SUCCESS",
   "confidence": 1.0
   }
   }

7. Tier1Agent receives completion, sends final response:
   {
   "name": "complete_agent_execution",
   "arguments": {
   "result": "Order #ORDER-789 has been cancelled and full refund of $299.99 processed. You'll see the refund in 3-5 business days. Refund tracking: REF-456789",
   "status": "SUCCESS",
   "confidence": 0.95
   }
   }

```

### 3.2 Software Development Workflow with External Integration

**Scenario:** A development team wants to automate code review processes using internal agents plus external specialized services.

**Repository Structure:**
```

dev-agents/
├── code/pr-reviewer/prompt.md
├── code/test-runner/prompt.md
└── deploy/staging-manager/prompt.md

````

**External Agent Registration:**
```graphql
mutation RegisterExternalSecurityAgent {
  createMcpServer(input: {
    name: "ExternalSecurityAuditor"
    description: "External security analysis service"
    type: A2A
    endpoint: "https://security-ai.partner.com/a2a/v1"
    apiKey: "encrypted-partner-key"
  }) {
    id
    discoveredAgents {
      name        # "external/security-auditor"
      description
    }
  }
}
````

**Agent Definition (code/pr-reviewer/prompt.md):**

```markdown
---
name: "CodeReviewer"
description: "Reviews pull requests for code quality, security issues, and best practices"
version: "1.5.0"
tags: ["development", "code-review", "security"]
model: "gpt-4-turbo"
providers: ["openai_gpt4"]
mcpServers: ["github", "sonarqube"]
allowedAgents:
  ["code/test-runner", "deploy/staging-manager", "external/security-auditor"]
examples:
  - "Review PR #123 for security vulnerabilities"
  - "Analyze code quality in payment module"
---

You are a Senior Code Reviewer responsible for maintaining code quality and security standards.

## Available Tools

- **github_get_pr**: Get pull request details and diff
- **sonarqube_scan**: Run code quality analysis
- **github_add_comment**: Add review comments

## Available Agents

- **code/test-runner**: Execute comprehensive test suites
- **deploy/staging-manager**: Handle staging deployments
- **external/security-auditor**: External security analysis service

## Review Process

1. Analyze code changes thoroughly
2. For security-sensitive changes, delegate to external/security-auditor
3. If code passes review, delegate to code/test-runner
4. Complete with approval/rejection decision

Your task: {{prompt}}
```

**Multi-System Execution:**

```
Request: "Review pull request #456 in payment-service repository"

1. CodeReviewer calls github_get_pr tool
   → Retrieves PR diff and details

2. CodeReviewer notices payment processing code, calls external agent:
   {
     "name": "call_agent",
     "arguments": {
       "agent_name": "external/security-auditor",
       "input": "Please audit the payment processing changes in PR #456. Focus on PCI compliance and data handling."
     }
   }

3. External security service processes via A2A protocol:
   POST https://security-ai.partner.com/a2a/v1
   {
     "method": "message/send",
     "params": {
       "message": {
         "role": "user",
         "parts": [{"kind": "text", "text": "Please audit..."}]
       }
     }
   }

4. External service completes and returns A2A task:
   {
     "id": "task-external-123",
     "status": {"state": "completed"},
     "artifacts": [{
       "parts": [{"kind": "text", "text": "Security audit passed. No PCI violations found..."}]
     }]
   }

5. CodeReviewer receives completion, calls internal test runner:
   {
     "name": "call_agent",
     "arguments": {
       "agent_name": "code/test-runner",
       "input": "Run full test suite for payment-service PR #456"
     }
   }

6. TestRunner executes and completes:
   {
     "name": "complete_agent_execution",
     "arguments": {
       "result": "All 247 tests passed. Coverage: 94.2%",
       "status": "SUCCESS",
       "confidence": 1.0
     }
   }

7. CodeReviewer calls github_add_comment and completes:
   {
     "name": "complete_agent_execution",
     "arguments": {
       "result": "PR #456 approved. External security audit passed, all tests passing. Ready for merge.",
       "status": "SUCCESS",
       "confidence": 0.95
     }
   }
```

### 3.3 Legal Document Analysis with Federated Expertise

**Scenario:** A company needs comprehensive contract analysis using both internal knowledge and external legal expertise.

**Repository Structure:**

```
main-agents/
├── legal/contract-coordinator/prompt.md
├── legal/compliance-checker/prompt.md
└── legal/risk-assessor/prompt.md

partner-agents/ (external A2A registrations)
└── external/specialized-legal-ai
```

**Multi-Repository Agent Coordination:**

```
Request: "Analyze this NDA for potential risks and compliance issues"

1. legal/contract-coordinator (internal git agent):
   - Initial document analysis
   - Calls legal/compliance-checker (same repo)
   - Calls legal/risk-assessor (same repo)

2. For specialized legal expertise, calls external agent:
   {
     "name": "call_agent",
     "arguments": {
       "agent_name": "external/specialized-legal-ai",
       "input": "Provide expert legal analysis of this NDA focusing on IP protection and liability clauses"
     }
   }

3. External A2A agent processes request:
   - Receives A2A message via HTTPS
   - Performs specialized legal analysis
   - Returns structured legal opinion

4. Internal coordinator combines all analysis:
   - Internal compliance check results
   - Internal risk assessment
   - External expert legal opinion
   - Generates comprehensive recommendation
```

### 3.4 Cross-Organization Agent Federation

**Scenario:** Multiple organizations want to share specialized agents while maintaining security boundaries.

**Organization A (Financial Services):**

```
Exposes via A2A:
- public/risk-calculator
- public/compliance-validator

Consumes externally:
- partner-bank/fraud-detector
- regtech-vendor/aml-screener
```

**Organization B (RegTech Vendor):**

```
Exposes via A2A:
- public/aml-screener
- public/kyc-validator

Consumes externally:
- finserv-partner/risk-calculator
- data-vendor/sanctions-checker
```

**Configuration Example:**

```json
{
  "agentRepositories": [
    {
      "name": "main-agents",
      "gitUrl": "https://github.com/company/agents.git",
      "isRoot": true,
      "branch": "production"
    }
  ],

  "agentExposure": {
    "allowedPrefixes": ["public/"],
    "securitySchemes": {
      "oauth2": {
        "type": "oauth2",
        "flows": {
          "clientCredentials": {
            "tokenUrl": "https://auth.company.com/oauth/token"
          }
        }
      }
    }
  },

  "externalAgents": {
    "partner-bank": {
      "endpoint": "https://agents.partner-bank.com/a2a/v1",
      "authentication": {
        "type": "oauth2",
        "clientId": "company-integration",
        "clientSecret": "env(PARTNER_BANK_SECRET)"
      }
    }
  }
}
```

## 4. Detailed System Architecture

### 4.1 Component Overview

```
┌──────────────────────────┐    ┌───────────────────── ──┐    ┌─────────────────────┐
│     GraphQL Client       │    │      A2A Client        │    │      Shaman UI      │
│     (External Apps)      │    │   (External Agent)     │    │ (Admin Dashboard)   │
└──────────┬───────────────┘    └───────┬────────────────┘    └───┬─────────────────┘
           │                            │                         │
           └──────┐                ┌────┘           ┌─────────────┘
                  │                │                │
                ┌─▼────────────────▼────────────────▼─────────────────┐
                │                         Shaman Server               │
                │ ┌───────────────────┐  ┌──────────────────────────┐ │
                │ │    GraphQL API    │  │         A2A Gateway      │ │
                │ │      Engine       │  │      (HTTP Endpoints)    │ │
                │ └───────────────────┘  └──────────────────────────┘ │
                │ ┌───────────────────┐  ┌──────────────────────────┐ │
                │ │    Real-time      │  │    Git Agent Discovery   │ │
                │ │     Streaming     │  │         Service          │ │
                │ └───────────────────┘  └──────────────────────────┘ │
                │ ┌───────────────────┐  ┌───────────────────────── ┐ │
                │ │   External A2A    │  │      Workflow Engine     │ │
                │ │     Registry      │  │         Adapter          │ │
                │ └───────────────────┘  └──────────────────────────┘ │
                └────────────────────────┬────────────────────────────┘
                                         │
                ┌────────────────────────▼────────────────────┐
                │                   Workflow Engine           │
                │ ┌────────────────┐    ┌───────────────────┐ │
                │ │   Temporal.io  │    │   BullMQ + Redis  │ │
                │ │  (Production)  │    │  (Development)    │ │
                │ └────────────────┘    └───────────────────┘ │
                └──────────────────────┬──────────────────────┘
                                       │
                ┌──────────────────────▼───────────────────────────────────┐
                │                      Worker Pool                         │
                │  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐ │
                │  │      LLM      │  │      MCP      │  │   A2A Client  │ │
                │  │     Calls     │  │     Tools     │  │     Logic     │ │
                │  └───────────────┘  └───────────────┘  └───────────────┘ │
                │  ┌─────────────────────────────────────────────────────┐ │
                │  │                   Tool Call Router                  │ │
                │  │  ┌───────────┐  ┌───────────────┐  ┌──────────────┐ │ │
                │  │  │    MCP    │  │    System     │  │    Agent     │ │ │
                │  │  │   Handler │  │    Handler    │  │     Call     │ │ │
                │  │  └───────────┘  └───────────────┘  └──────────────┘ │ │
                │  └─────────────────────────────────────────────────────┘ │
                │  ┌─────────────────────────────────────────────────────┐ │
                │  │               Git Agent Resolver                    │ │
                │  │  ┌───────────┐    ┌──────────┐    ┌──────────────┐  │ │
                │  │  │    Root   │    │ Namespd  │    │   External   │  │ │
                │  │  │   Repos   │    │  Repos   │    │ A2A Registry │  │ │
                │  │  └───────────┘    └──────────┘    └──────────────┘  │ │
                │  └─────────────────────────────────────────────────────┘ │
                └────────────────────────┬─────────────────────────────────┘
                                         │
                ┌────────────────────────▼───────────────────────────────────┐
                │                     Infrastructure                         │
                │  ┌───────────────┐  ┌───────────────┐  ┌─────────────────┐ │
                │  │   PostgreSQL  │  │     Redis     │  │ OpenTelemetry   │ │
                │  │     (Data)    │  │   (Streams)   │  │   (Tracing)     │ │
                │  └───────────────┘  └───────────────┘  └─────────────────┘ │
                │  ┌───────────────────────────────────────────────────────┐ │
                │  │                    Git Storage                        │ │
                │  │  ┌──────────┐  ┌───────────┐  ┌─────────────┐         │ │
                │  │  │  Cloned  │  │  Cached   │  │    Sync     │         │ │
                │  │  │  Repos   │  │  Agents   │  │  Metadata   │         │ │
                │  │  └──────────┘  └───────────┘  └─────────────┘         │ │
                │  └───────────────────────────────────────────────────────┘ │
                └────────────────────────────────────────────────────────────┘

```

### 4.2 Shaman Server (Control Plane & Gateway)

The `packages/shaman` Node.js application, serving as the system's nerve center.

#### 4.2.1 GraphQL API Engine

- **Technology:** Apollo Server with GraphQL subscriptions over WebSockets
- **Authentication:** JWT-based with role-based access control (RBAC)
- **Authorization:** Field-level permissions based on user roles and git repository access
- **Rate Limiting:** Per-user and per-endpoint limits to prevent abuse
- **Validation:** Comprehensive input validation with detailed error messages

#### 4.2.2 A2A Gateway

- **HTTP Server:** Express.js endpoints implementing A2A JSON-RPC methods
- **Request Routing:** Routes A2A requests to appropriate git-based agents
- **AgentCard Generation:** Dynamic generation from git agent definitions
- **Authentication:** Configurable security schemes per exposed agent path
- **Response Translation:** Git agent completions → A2A task/message format
- **Streaming Support:** A2A SSE streaming for long-running git agent executions

#### 4.2.3 Git Agent Discovery Service

```typescript
interface GitAgentDiscoveryService {
  syncRepository(repoName: string): Promise<SyncResult>;
  syncAllRepositories(): Promise<SyncResult[]>;
  findAgent(agentName: string): Promise<GitAgent | null>;
  resolveAgentPath(agentName: string): Promise<AgentResolution>;
  listAgents(filters?: AgentFilters): Promise<GitAgent[]>;
  getAgentHistory(agentName: string): Promise<GitCommit[]>;
}

interface AgentResolution {
  agentName: string;
  repositoryName: string;
  filePath: string;
  isNamespaced: boolean;
  gitCommit: string;
}

interface GitAgent {
  name: string;
  description: string;
  version: string;
  tags: string[];
  model: string;
  providers: string[];
  mcpServers: string[];
  allowedAgents: string[];

  // Git metadata
  repositoryName: string;
  filePath: string;
  gitCommit: string;
  lastModified: Date;

  // Parsed content
  promptTemplate: string;
  frontmatter: AgentFrontmatter;
}
```

#### 4.2.4 External A2A Registry

```typescript
interface ExternalA2ARegistry {
  registerAgent(config: A2AAgentConfig): Promise<ExternalAgent>;
  discoverAgents(endpoint: string): Promise<ExternalAgent[]>;
  getAgentCard(agentName: string): Promise<A2AAgentCard>;
  healthCheck(agentName: string): Promise<HealthStatus>;
  listExternalAgents(): Promise<ExternalAgent[]>;
}

interface ExternalAgent {
  name: string;
  description: string;
  endpoint: string;
  agentCard: A2AAgentCard;
  authConfig: A2AAuthConfig;
  isActive: boolean;
  lastHealthCheck: Date;
}
```

#### 4.2.5 Real-time Streaming Hub

- **WebSocket Management:** Handles GraphQL subscription connections
- **Redis Pub/Sub:** Subscribes to worker-generated stream events
- **Event Filtering:** Ensures clients only receive authorized events
- **Connection Scaling:** Supports horizontal scaling with Redis clustering
- **Input Request Notifications:** Real-time alerts when agents request user input

#### 4.2.6 Operational Constraints

- **No LLM Calls:** Server never directly calls LLM providers
- **Stateless Design:** All persistent state in PostgreSQL/Redis
- **High Availability:** Designed for multi-instance deployment
- **Git Synchronization:** Periodic syncing of agent repositories

### 4.3 Workflow Engine (Execution Plane)

Pluggable backend for durable workflow execution with git versioning and completion support.

#### 4.3.1 Temporal.io Adapter (Production)

- **Workflows:** `executeAgentStep` workflow with child workflow support
- **Activities:** `callLLM`, `executeTool`, `executeChildAgent`, `saveMemory`, `publishStream`, `resolveGitAgent`
- **Git Version Tracking:** Each execution captures exact git commit for traceability
- **Completion Handling:** Native support for waiting on explicit completion signals
- **Durability:** Automatic state persistence and recovery
- **Scaling:** Horizontal worker scaling with automatic load balancing

#### 4.3.2 BullMQ Adapter (Development)

- **Queue Structure:** Single queue with job prioritization
- **Jobs:** `executeStep` jobs with retry policies and completion detection
- **Git Integration:** Jobs include git commit references for agent resolution
- **Redis Backend:** Requires Redis for job persistence and completion signaling
- **Simplified Logic:** Easier local development and testing

#### 4.3.3 Interface Definition

```typescript
interface WorkflowEngineAdapter {
  startRuns(inputs: RunAgentInput[]): Promise<RunIdentifier[]>;
  getRun(id: RunIdentifier): Promise<Run | null>;
  listRuns(options: ListRunsOptions): Promise<Run[]>;
  getRunHistory(id: RunIdentifier): Promise<Step[]>;
  terminateRun(id: RunIdentifier): Promise<boolean>;
  pauseRun(id: RunIdentifier): Promise<boolean>;
  resumeRun(id: RunIdentifier, userInput?: string): Promise<boolean>;
  handleCompletion(stepId: string, completion: AgentCompletion): Promise<void>;
  getEngineStatus(): Promise<EngineStatus>;
  engineType: string;
}

interface AgentCompletion {
  result: string;
  status: "SUCCESS" | "PARTIAL" | "FAILED";
  confidence: number;
  requiresFollowup: boolean;
  metadata?: any;
}
```

### 4.4 Worker Process (Execution Units)

Scalable Node.js processes performing the actual agent execution with git resolution and completion handling.

#### 4.4.1 Core Responsibilities

- **Job Consumption:** Pull and execute jobs from workflow engine
- **Git Agent Resolution:** Load agent definitions from git repositories at specific commits
- **LLM Interaction:** Only component making direct LLM API calls
- **Tool Execution:** Handle MCP and A2A tool calls
- **Agent Completion:** Process and validate explicit completion tool calls
- **Child Agent Coordination:** Manage agent-to-agent calls with completion waiting
- **External A2A Communication:** Handle calls to external A2A agents
- **Stream Publishing:** Push real-time events to Redis

#### 4.4.2 Git Agent Resolution

```typescript
interface GitAgentResolver {
  resolveAgent(agentName: string, requestTime?: Date): Promise<ResolvedAgent>;
  loadAgentDefinition(
    repo: string,
    path: string,
    commit: string
  ): Promise<AgentDefinition>;
  parseAgentFrontmatter(markdown: string): Promise<AgentFrontmatter>;
  validateAgentDefinition(definition: AgentDefinition): ValidationResult;
}

class GitAgentResolverImpl implements GitAgentResolver {
  async resolveAgent(agentName: string): Promise<ResolvedAgent> {
    // 1. Check root repositories first (unnamespaced)
    for (const rootRepo of this.rootRepositories) {
      const agent = await this.findAgentInRepo(rootRepo, agentName);
      if (agent) {
        return {
          agent: agent,
          source: "git",
          repository: rootRepo.name,
          commit: rootRepo.currentCommit,
          isNamespaced: false,
        };
      }
    }

    // 2. Check namespaced repositories
    if (agentName.includes("/")) {
      const [namespace, ...pathParts] = agentName.split("/");
      const agentPath = pathParts.join("/");

      const namespacedRepo = this.namedRepositories.get(namespace);
      if (namespacedRepo) {
        const agent = await this.findAgentInRepo(namespacedRepo, agentPath);
        if (agent) {
          return {
            agent: agent,
            source: "git",
            repository: namespacedRepo.name,
            commit: namespacedRepo.currentCommit,
            isNamespaced: true,
          };
        }
      }
    }

    // 3. Check external A2A agents
    const externalAgent = await this.externalA2ARegistry.findAgent(agentName);
    if (externalAgent) {
      return {
        agent: externalAgent,
        source: "a2a",
        endpoint: externalAgent.endpoint,
        isNamespaced: false,
      };
    }

    throw new Error(
      `Agent ${agentName} not found in any repository or external registry`
    );
  }

  async loadAgentDefinition(
    repo: string,
    path: string,
    commit: string
  ): Promise<AgentDefinition> {
    // Load specific version of agent from git
    const markdown = await this.gitService.getFile(repo, path, commit);
    const parsed = await this.parseAgentFrontmatter(markdown);

    return {
      frontmatter: parsed.frontmatter,
      promptTemplate: parsed.content,
      gitMetadata: {
        repository: repo,
        filePath: path,
        commit: commit,
        lastModified: await this.gitService.getFileLastModified(
          repo,
          path,
          commit
        ),
      },
    };
  }
}
```

#### 4.4.3 LLM Integration

- **Vercel AI SDK:** Primary interface for all LLM interactions
- **Provider Abstraction:** Support for OpenAI, Anthropic, Groq, Ollama
- **Streaming Support:** Real-time token streaming with chunk aggregation
- **Error Handling:** Comprehensive retry policies and error categorization
- **Tool Injection:** Automatically provides system tools to all agents
- **Prompt Template Resolution:** Injects available tools and agents into templates

#### 4.4.4 A2A Client Implementation

```typescript
interface A2AClientHandler {
  callExternalAgent(
    agentName: string,
    input: string,
    context: ExecutionContext
  ): Promise<AgentCompletion>;
  discoverExternalAgent(endpoint: string): Promise<A2AAgentCard>;
  translateToA2AMessage(input: string, context: ExecutionContext): A2AMessage;
  translateFromA2ATask(task: A2ATask): AgentCompletion;
}

class A2AClientHandlerImpl implements A2AClientHandler {
  async callExternalAgent(
    agentName: string,
    input: string,
    context: ExecutionContext
  ): Promise<AgentCompletion> {
    const externalAgent = await this.externalA2ARegistry.findAgent(agentName);
    if (!externalAgent) {
      throw new Error(`External agent ${agentName} not registered`);
    }

    // 1. Prepare A2A message
    const a2aMessage: A2AMessage = {
      role: "user",
      parts: [{ kind: "text", text: input }],
      messageId: generateId(),
      taskId: context.currentStep.runId,
      contextId: context.currentStep.runId,
    };

    // 2. Send A2A request
    const response = await this.sendA2ARequest(externalAgent, {
      jsonrpc: "2.0",
      id: generateId(),
      method: "message/send",
      params: {
        message: a2aMessage,
        configuration: {
          acceptedOutputModes: ["text/plain", "application/json"],
          blocking: true,
        },
      },
    });

    // 3. Handle response
    if (response.result.kind === "task") {
      return await this.waitForA2ATaskCompletion(
        externalAgent,
        response.result
      );
    } else if (response.result.kind === "message") {
      return this.translateMessageToCompletion(response.result);
    }

    throw new Error("Invalid A2A response format");
  }

  private async waitForA2ATaskCompletion(
    agent: ExternalAgent,
    task: A2ATask
  ): Promise<AgentCompletion> {
    // Poll or stream the external task until completion
    let currentTask = task;

    while (!this.isTerminalState(currentTask.status.state)) {
      await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1 second

      const response = await this.sendA2ARequest(agent, {
        jsonrpc: "2.0",
        id: generateId(),
        method: "tasks/get",
        params: { id: currentTask.id },
      });

      currentTask = response.result;
    }

    return this.translateTaskToCompletion(currentTask);
  }

  private translateTaskToCompletion(task: A2ATask): AgentCompletion {
    const isSuccess = task.status.state === "completed";
    const result =
      task.artifacts?.length > 0
        ? this.extractTextFromArtifacts(task.artifacts)
        : task.status.message?.parts
            ?.map((p) => (p.kind === "text" ? p.text : ""))
            .join("") || "No result";

    return {
      result: result,
      status: isSuccess ? "SUCCESS" : "FAILED",
      confidence: isSuccess ? 0.9 : 0.0,
      requiresFollowup:
        task.status.state === "input-required" ||
        task.status.state === "auth-required",
      metadata: {
        externalTaskId: task.id,
        finalState: task.status.state,
        artifacts: task.artifacts?.length || 0,
      },
    };
  }
}
```

#### 4.4.5 Tool Call Router

```typescript
interface ToolCallRouter {
  routeToolCall(
    toolCall: ToolCall,
    context: ExecutionContext
  ): Promise<ToolResult>;
}

class ToolCallRouterImpl implements ToolCallRouter {
  async routeToolCall(
    toolCall: ToolCall,
    context: ExecutionContext
  ): Promise<ToolResult> {
    const { name, arguments: args } = toolCall.function;

    switch (name) {
      case "call_agent":
        return await this.agentCallHandler.handleAgentCall(args, context);

      case "complete_agent_execution":
        return await this.systemHandler.handleCompletion(args, context);

      case "request_user_input":
        return await this.systemHandler.handleInputRequest(args, context);

      case "save_memory":
      case "load_memory":
        return await this.systemHandler.handleMemory(name, args, context);

      default:
        // Handle MCP tool
        return await this.mcpHandler.callMcpTool(name, args, context);
    }
  }
}
```

#### 4.4.6 Agent Call Handler Implementation

```typescript
interface AgentCallHandler {
  handleAgentCall(
    args: AgentCallArgs,
    context: ExecutionContext
  ): Promise<ToolResult>;
}

class AgentCallHandlerImpl implements AgentCallHandler {
  async handleAgentCall(
    args: AgentCallArgs,
    context: ExecutionContext
  ): Promise<ToolResult> {
    const { agent_name, input, context_scope = "FULL" } = args;

    // 1. Resolve agent (git or external A2A)
    const resolvedAgent = await this.gitAgentResolver.resolveAgent(agent_name);

    // 2. Validate permissions
    await this.validateAgentCallPermissions(context.currentAgent, agent_name);

    // 3. Prevent circular calls
    this.validateNoCircularCalls(context.callStack, agent_name);

    // 4. Execute based on agent source
    let completion: AgentCompletion;

    if (resolvedAgent.source === "git") {
      completion = await this.executeGitAgent(resolvedAgent, input, context);
    } else if (resolvedAgent.source === "a2a") {
      completion = await this.a2aClientHandler.callExternalAgent(
        agent_name,
        input,
        context
      );
    } else {
      throw new Error(`Unknown agent source: ${resolvedAgent.source}`);
    }

    // 5. Return completion as tool result
    return {
      success: completion.status !== "FAILED",
      result: completion.result,
      metadata: {
        status: completion.status,
        confidence: completion.confidence,
        requiresFollowup: completion.requiresFollowup,
        agentSource: resolvedAgent.source,
        gitCommit: resolvedAgent.commit,
        executionTime: completion.metadata?.executionTime,
        cost: completion.metadata?.cost,
      },
    };
  }

  private async executeGitAgent(
    resolvedAgent: ResolvedAgent,
    input: string,
    context: ExecutionContext
  ): Promise<AgentCompletion> {
    // Start child agent execution with git version tracking
    const childRun = await this.startChildAgentRun({
      agentName: resolvedAgent.agent.name,
      agentSource: "git",
      gitRepository: resolvedAgent.repository,
      gitCommit: resolvedAgent.commit,
      input: input,
      contextScope: context_scope,
      parentStepId: context.currentStep.id,
      parentRunId: context.currentStep.runId,
      callStack: [...context.callStack, context.currentAgent.name],
    });

    // Wait for explicit completion
    return await this.waitForAgentCompletion(childRun.id);
  }
}
```

#### 4.4.7 Prompt Template Resolution

```typescript
interface PromptTemplateResolver {
  resolvePromptTemplate(agent: GitAgent, userInput: string): Promise<string>;
}

class PromptTemplateResolverImpl implements PromptTemplateResolver {
  async resolvePromptTemplate(
    agent: GitAgent,
    userInput: string
  ): Promise<string> {
    const availableTools = await this.getMcpServerTools(agent.mcpServers);
    const allowedAgents = await this.resolveAllowedAgents(agent.allowedAgents);

    // Add system tools
    const allTools = [...availableTools, ...this.getSystemTools()];

    // Resolve template variables
    return agent.promptTemplate
      .replace("{{agent_name}}", agent.name)
      .replace("{{agent_description}}", agent.description)
      .replace("{{prompt}}", userInput)
      .replace("{{available_tools}}", this.formatToolsForPrompt(allTools))
      .replace("{{allowed_agents}}", this.formatAgentsForPrompt(allowedAgents));
  }

  private async resolveAllowedAgents(
    allowedAgentNames: string[]
  ): Promise<AgentSummary[]> {
    const agents: AgentSummary[] = [];

    for (const agentName of allowedAgentNames) {
      try {
        const resolved = await this.gitAgentResolver.resolveAgent(agentName);
        agents.push({
          name: agentName,
          description: resolved.agent.description,
          examples: resolved.agent.examples || [],
          source: resolved.source,
        });
      } catch (error) {
        console.warn(`Could not resolve allowed agent: ${agentName}`, error);
      }
    }

    return agents;
  }

  private formatAgentsForPrompt(agents: AgentSummary[]): string {
    return agents
      .map((agent) => {
        const sourceIndicator = agent.source === "a2a" ? " (external)" : "";
        return `- **${agent.name}${sourceIndicator}**: ${
          agent.description
        }\n  Examples: ${agent.examples.join(", ") || "General tasks"}`;
      })
      .join("\n");
  }
}
```

## 5. Agent Repository Management

### 5.1 Git Repository Structure

#### 5.1.1 Agent Definition Format

```markdown
---
name: "SalesAssistant"
description: "Helps with sales inquiries and lead qualification"
version: "1.3.0"
tags: ["sales", "lead-qualification", "customer-engagement"]
model: "gpt-4-turbo"
providers: ["openai_gpt4", "anthropic_claude"]
mcpServers: ["crm-tools", "email-templates", "calendar-integration"]
allowedAgents: ["sales/proposal-generator", "external/legal-reviewer"]
examples:
  - "Qualify this lead for our enterprise product"
  - "Generate a follow-up email for this prospect"
  - "Schedule a demo call with the customer"
contextScope: "FULL"
maxExecutionMinutes: 15
---

You are a Sales Assistant AI specialized in lead qualification and customer engagement.

## Your Role

- Qualify leads based on company criteria
- Generate personalized communications
- Schedule appropriate follow-up actions
- Escalate complex deals to human sales reps

## Available Tools

Your tools will be automatically injected based on your configured MCP servers:

- CRM operations (create/update leads, accounts)
- Email template generation and sending
- Calendar management and scheduling

## Available Agents

You can delegate specialized tasks to: {{allowed_agents}}

## Process Guidelines

1. Always gather basic qualification information first
2. Use sales/proposal-generator for complex RFPs
3. Use external/legal-reviewer for contract-related questions
4. Complete with next steps and confidence assessment

Your task: {{prompt}}
```

#### 5.1.2 Repository Structure Examples

**Root Repository (unnamespaced):**

```
main-agents/
├── sales/
│   ├── assistant/prompt.md              → "sales/assistant"
│   ├── proposal-generator/prompt.md     → "sales/proposal-generator"
│   └── deal-analyzer/prompt.md          → "sales/deal-analyzer"
├── support/
│   ├── tier1/prompt.md                  → "support/tier1"
│   ├── billing/prompt.md                → "support/billing"
│   └── technical/prompt.md              → "support/technical"
├── legal/
│   ├── contract-review/prompt.md        → "legal/contract-review"
│   └── compliance/prompt.md             → "legal/compliance"
└── public/
    ├── demo-agent/prompt.md             → "public/demo-agent"
    └── api-helper/prompt.md             → "public/api-helper"
```

**Namespaced Repository:**

```
experimental-agents/
├── nlp/
│   ├── sentiment-analysis/prompt.md     → "experimental/nlp/sentiment-analysis"
│   └── text-classification/prompt.md   → "experimental/nlp/text-classification"
├── vision/
│   ├── object-detection/prompt.md       → "experimental/vision/object-detection"
│   └── image-analysis/prompt.md         → "experimental/vision/image-analysis"
└── research/
    ├── paper-analysis/prompt.md         → "experimental/research/paper-analysis"
    └── trend-detection/prompt.md        → "experimental/research/trend-detection"
```

### 5.2 Git Repository Configuration

```json
{
  "agentRepositories": [
    {
      "name": "main-agents",
      "gitUrl": "https://github.com/company/main-agents.git",
      "branch": "production",
      "isRoot": true,
      "syncInterval": "5m",
      "authType": "ssh-key",
      "sshKeyPath": "/secrets/git-deploy-key",
      "webhookSecret": "env(GIT_WEBHOOK_SECRET)",
      "isActive": true
    },
    {
      "name": "experimental",
      "gitUrl": "https://github.com/company/experimental-agents.git",
      "branch": "main",
      "isRoot": false,
      "syncInterval": "15m",
      "authType": "token",
      "authToken": "env(GITHUB_TOKEN)",
      "isActive": true
    },
    {
      "name": "partner-shared",
      "gitUrl": "https://github.com/partner/shared-agents.git",
      "branch": "stable",
      "isRoot": false,
      "syncInterval": "1h",
      "authType": "ssh-key",
      "sshKeyPath": "/secrets/partner-git-key",
      "isActive": true,
      "readOnly": true
    }
  ]
}
```

### 5.3 Git Synchronization API

```graphql
type AgentRepository {
  id: ID!
  name: String!
  gitUrl: String!
  branch: String!
  isRoot: Boolean!
  isActive: Boolean!
  readOnly: Boolean!
  lastSyncCommit: String
  lastSyncAt: DateTime
  lastSyncStatus: SyncStatus!
  agentCount: Int!
  discoveredAgents: [GitAgent!]!
  syncErrors: [SyncError!]!
}

type GitAgent {
  name: String!
  description: String!
  version: String!
  tags: [String!]!

  # Git metadata
  repository: AgentRepository!
  filePath: String!
  gitCommit: String!
  lastModified: DateTime!

  # Configuration
  model: String
  providers: [String!]!
  mcpServers: [String!]!
  allowedAgents: [String!]!
  examples: [String!]!

  # Analytics
  usageCount: Int!
  lastUsed: DateTime
  averageExecutionTime: Float
}

enum SyncStatus {
  SUCCESS
  IN_PROGRESS
  FAILED
  NEVER_SYNCED
}

type SyncError {
  message: String!
  filePath: String
  timestamp: DateTime!
  errorType: String!
}

type Mutation {
  # Repository management
  addAgentRepository(input: AddAgentRepositoryInput!): AgentRepository!
  updateAgentRepository(
    id: ID!
    input: UpdateAgentRepositoryInput!
  ): AgentRepository!
  removeAgentRepository(id: ID!): Boolean!

  # Git synchronization
  syncAgentRepository(name: String!): AgentRepository!
  syncAllAgentRepositories: [AgentRepository!]!

  # Branch management
  switchRepositoryBranch(name: String!, branch: String!): AgentRepository!
}

type Query {
  # Repository queries
  agentRepository(name: String!): AgentRepository
  agentRepositories: [AgentRepository!]!

  # Agent discovery
  gitAgent(name: String!): GitAgent
  gitAgents(repositoryName: String, filters: GitAgentFilters): [GitAgent!]!

  # Git operations
  agentGitHistory(agentName: String!, limit: Int = 10): [GitCommit!]!
  gitBranches(repositoryName: String!): [String!]!
  gitTags(repositoryName: String!): [String!]!
}

type GitCommit {
  hash: String!
  message: String!
  author: String!
  timestamp: DateTime!
  changedFiles: [String!]!
}
```

### 5.4 Agent Resolution Priority

```typescript
class AgentResolver {
  async resolveAgent(requestedName: string): Promise<ResolvedAgent> {
    // 1. Check root repositories first (unnamespaced access)
    for (const rootRepo of this.rootRepositories) {
      const agent = await this.findAgentInRepository(rootRepo, requestedName);
      if (agent) {
        return {
          agent: agent,
          source: "git",
          repository: rootRepo.name,
          isNamespaced: false,
          priority: "root",
        };
      }
    }

    // 2. Check namespaced repositories
    if (requestedName.includes("/")) {
      const parts = requestedName.split("/");

      // Try namespace/path pattern (e.g., "experimental/nlp/sentiment")
      for (let i = 1; i < parts.length; i++) {
        const namespace = parts.slice(0, i).join("/");
        const agentPath = parts.slice(i).join("/");

        const namespacedRepo = this.namedRepositories.get(namespace);
        if (namespacedRepo) {
          const agent = await this.findAgentInRepository(
            namespacedRepo,
            agentPath
          );
          if (agent) {
            return {
              agent: agent,
              source: "git",
              repository: namespacedRepo.name,
              isNamespaced: true,
              priority: "namespaced",
            };
          }
        }
      }
    }

    // 3. Check external A2A agents
    const externalAgent = await this.externalA2ARegistry.findAgent(
      requestedName
    );
    if (externalAgent) {
      return {
        agent: externalAgent,
        source: "a2a",
        isNamespaced: false,
        priority: "external",
      };
    }

    throw new AgentNotFoundError(
      `Agent "${requestedName}" not found in any git repository or external registry`
    );
  }

  async findAgentInRepository(
    repo: AgentRepository,
    agentPath: string
  ): Promise<GitAgent | null> {
    const expectedFiles = [
      `${agentPath}/prompt.md`,
      `${agentPath}/agent.md`,
      `${agentPath}.md`,
    ];

    for (const filePath of expectedFiles) {
      try {
        const content = await this.gitService.getFile(
          repo.name,
          filePath,
          repo.currentCommit
        );
        if (content) {
          return await this.parseAgentDefinition(repo, filePath, content);
        }
      } catch (error) {
        // File doesn't exist, try next
        continue;
      }
    }

    return null;
  }
}
```

## 6. A2A Integration & Federation

### 6.1 Exposing Git-Based Agents via A2A

#### 6.1.1 A2A Gateway Configuration

```json
{
  "agentExposure": {
    "enabled": true,
    "basePath": "/a2a/v1",
    "allowedAgents": ["support/tier1", "support/billing", "public/demo-agent"],
    "allowedPrefixes": ["public/", "api/"],
    "blockedAgents": ["internal/experimental", "admin/system-tools"],
    "requiresAuthentication": true,
    "defaultSecuritySchemes": {
      "apiKey": {
        "type": "apiKey",
        "in": "header",
        "name": "X-API-Key"
      },
      "oauth2": {
        "type": "oauth2",
        "flows": {
          "clientCredentials": {
            "tokenUrl": "https://auth.company.com/oauth/token",
            "scopes": {
              "agent:execute": "Execute agents",
              "agent:stream": "Stream agent responses"
            }
          }
        }
      }
    },
    "rateLimiting": {
      "requestsPerMinute": 60,
      "requestsPerHour": 1000,
      "requestsPerDay": 10000
    }
  }
}
```

#### 6.1.2 Dynamic AgentCard Generation

```typescript
interface A2AAgentCardGenerator {
  generateAgentCard(): Promise<A2AAgentCard>;
  generateSkillsFromGitAgents(allowedAgents: string[]): Promise<A2ASkill[]>;
}

class A2AAgentCardGeneratorImpl implements A2AAgentCardGenerator {
  async generateAgentCard(): Promise<A2AAgentCard> {
    const allowedAgents = await this.getExposableAgents();
    const skills = await this.generateSkillsFromGitAgents(allowedAgents);

    return {
      name: "Company AI Agent Platform",
      description:
        "Enterprise AI agents for customer support, sales, and operations",
      url: `${this.config.baseUrl}/a2a/v1`,
      version: "1.0.0",
      provider: {
        organization: this.config.organization,
        url: this.config.organizationUrl,
      },
      capabilities: {
        streaming: true,
        pushNotifications: false,
        stateTransitionHistory: true,
      },
      securitySchemes: this.config.agentExposure.defaultSecuritySchemes,
      security: [{ apiKey: [] }, { oauth2: ["agent:execute"] }],
      defaultInputModes: ["text/plain", "application/json"],
      defaultOutputModes: ["text/plain", "application/json"],
      skills: skills,
      supportsAuthenticatedExtendedCard: true,
    };
  }

  async generateSkillsFromGitAgents(agentNames: string[]): Promise<A2ASkill[]> {
    const skills: A2ASkill[] = [];

    for (const agentName of agentNames) {
      try {
        const resolved = await this.gitAgentResolver.resolveAgent(agentName);

        skills.push({
          id: agentName,
          name: resolved.agent.name,
          description: resolved.agent.description,
          tags: resolved.agent.tags,
          examples: resolved.agent.examples,
          inputModes: ["text/plain", "application/json"],
          outputModes: ["text/plain", "application/json"],
        });
      } catch (error) {
        console.warn(
          `Could not resolve agent for A2A exposure: ${agentName}`,
          error
        );
      }
    }

    return skills;
  }
}
```

#### 6.1.3 A2A Request Handling

```typescript
interface A2ARequestHandler {
  handleMessageSend(params: A2AMessageSendParams): Promise<A2AResponse>;
  handleMessageStream(
    params: A2AMessageSendParams
  ): AsyncIterableIterator<A2AStreamEvent>;
  handleTasksGet(params: A2ATaskQueryParams): Promise<A2ATask>;
  handleTasksCancel(params: A2ATaskIdParams): Promise<A2ATask>;
}

class A2ARequestHandlerImpl implements A2ARequestHandler {
  async handleMessageSend(params: A2AMessageSendParams): Promise<A2AResponse> {
    // 1. Validate request and extract agent skill
    const skillId = this.extractSkillFromMessage(params.message);
    const agentName = skillId; // Skills map directly to agent names

    // 2. Validate agent is exposed
    await this.validateAgentExposure(agentName);

    // 3. Convert A2A message to Shaman execution
    const runInput: RunAgentInput = {
      agentName: agentName,
      input: this.extractTextFromA2AParts(params.message.parts),
      contextScope: "FULL",
    };

    // 4. Execute agent via workflow engine
    const run = await this.workflowEngine.startRun(runInput);

    // 5. Handle based on configuration
    if (params.configuration?.blocking) {
      // Wait for completion and return result
      const completion = await this.waitForRunCompletion(run.id);
      return this.convertRunToA2ATask(completion);
    } else {
      // Return task for polling
      return this.convertRunToA2ATask(run);
    }
  }

  async *handleMessageStream(
    params: A2AMessageSendParams
  ): AsyncIterableIterator<A2AStreamEvent> {
    const agentName = this.extractSkillFromMessage(params.message);
    await this.validateAgentExposure(agentName);

    const runInput: RunAgentInput = {
      agentName: agentName,
      input: this.extractTextFromA2AParts(params.message.parts),
      contextScope: "FULL",
    };

    const run = await this.workflowEngine.startRun(runInput);

    // Stream real-time events
    const subscription = this.subscribeToRunEvents(run.id);

    try {
      for await (const event of subscription) {
        const a2aEvent = this.convertShamanEventToA2A(event, run.id);
        if (a2aEvent) {
          yield a2aEvent;
        }

        // End stream on terminal state
        if (this.isTerminalState(event.type)) {
          break;
        }
      }
    } finally {
      subscription.unsubscribe();
    }
  }
}
```

### 6.2 Consuming External A2A Agents

#### 6.2.1 External Agent Registration

```graphql
type ExternalA2AAgent {
  id: ID!
  name: String!
  description: String!
  endpoint: String!
  agentCard: JSON!
  authConfig: JSON!
  isActive: Boolean!
  lastHealthCheck: DateTime
  healthStatus: String!
  skills: [ExternalA2ASkill!]!
  usageCount: Int!
  averageResponseTime: Float
  errorRate: Float
}

type ExternalA2ASkill {
  id: String!
  name: String!
  description: String!
  tags: [String!]!
  examples: [String!]!
  inputModes: [String!]!
  outputModes: [String!]!
}

type Mutation {
  registerExternalA2AAgent(
    input: RegisterExternalA2AAgentInput!
  ): ExternalA2AAgent!
  updateExternalA2AAgent(
    id: ID!
    input: UpdateExternalA2AAgentInput!
  ): ExternalA2AAgent!
  removeExternalA2AAgent(id: ID!): Boolean!
  refreshExternalA2AAgent(id: ID!): ExternalA2AAgent!
  testExternalA2AConnection(id: ID!): Boolean!
}

input RegisterExternalA2AAgentInput {
  name: String!
  description: String
  endpoint: String!
  authConfig: ExternalA2AAuthInput!
  autoDiscover: Boolean = true
  healthCheckInterval: String = "5m"
}

input ExternalA2AAuthInput {
  type: String! # "apiKey", "oauth2", "basic", "none"
  apiKey: String
  oauthClientId: String
  oauthClientSecret: String
  oauthTokenUrl: String
  basicUsername: String
  basicPassword: String
}
```

#### 6.2.2 External Agent Discovery and Health Monitoring

```typescript
interface ExternalA2ADiscoveryService {
  discoverAgent(
    endpoint: string,
    authConfig: A2AAuthConfig
  ): Promise<ExternalA2AAgent>;
  refreshAgentCard(agentId: string): Promise<A2AAgentCard>;
  healthCheck(agentId: string): Promise<HealthStatus>;
  scheduleHealthChecks(): void;
}

class ExternalA2ADiscoveryServiceImpl implements ExternalA2ADiscoveryService {
  async discoverAgent(
    endpoint: string,
    authConfig: A2AAuthConfig
  ): Promise<ExternalA2AAgent> {
    // 1. Fetch public agent card
    const publicCardUrl = `${endpoint}/../.well-known/agent.json`;
    const publicCard = await this.fetchAgentCard(publicCardUrl);

    // 2. Test authentication
    await this.validateAuthentication(
      endpoint,
      authConfig,
      publicCard.security
    );

    // 3. Fetch authenticated extended card if available
    let finalCard = publicCard;
    if (publicCard.supportsAuthenticatedExtendedCard) {
      try {
        const authCardUrl = `${endpoint}/../agent/authenticatedExtendedCard`;
        finalCard = await this.fetchAgentCard(authCardUrl, authConfig);
      } catch (error) {
        console.warn("Could not fetch authenticated extended card:", error);
      }
    }

    // 4. Generate agent name mapping
    const agentName = this.generateAgentName(endpoint, finalCard);

    // 5. Create external agent record
    return {
      name: agentName,
      description: finalCard.description,
      endpoint: endpoint,
      agentCard: finalCard,
      authConfig: authConfig,
      skills: finalCard.skills,
      isActive: true,
      lastHealthCheck: new Date(),
      healthStatus: "healthy",
    };
  }

  private generateAgentName(endpoint: string, card: A2AAgentCard): string {
    // Generate namespace from domain
    const url = new URL(endpoint);
    const domain = url.hostname.replace(/\./g, "-");

    // Use first skill ID or domain
    const skillId = card.skills[0]?.id;
    if (skillId) {
      return `external/${domain}/${skillId}`;
    } else {
      return `external/${domain}/agent`;
    }
  }

  async healthCheck(agentId: string): Promise<HealthStatus> {
    const agent = await this.getExternalAgent(agentId);

    try {
      // Test basic connectivity
      const testMessage = {
        role: "user" as const,
        parts: [{ kind: "text" as const, text: "Health check ping" }],
        messageId: generateId(),
      };

      const response = await this.sendA2ARequest(agent, {
        jsonrpc: "2.0",
        id: "health-check",
        method: "message/send",
        params: {
          message: testMessage,
          configuration: {
            acceptedOutputModes: ["text/plain"],
            blocking: true,
          },
        },
      });

      return {
        status: "healthy",
        responseTime: response.responseTime,
        lastCheck: new Date(),
      };
    } catch (error) {
      return {
        status: "unhealthy",
        error: error.message,
        lastCheck: new Date(),
      };
    }
  }
}
```

#### 6.2.3 External A2A Call Integration in Git Agents

Git-based agents can call external A2A agents seamlessly:

```markdown
---
name: "ComprehensiveAnalyzer"
description: "Performs analysis using both internal and external specialized agents"
allowedAgents:
  [
    "internal/data-processor",
    "external/legal-expert",
    "external/financial-analyst",
  ]
---

You can delegate tasks to both internal and external agents:

## Internal Agents

- **internal/data-processor**: For data cleaning and analysis

## External Agents

- **external/legal-expert**: External legal analysis service
- **external/financial-analyst**: Partner financial modeling service

When calling external agents, they may take longer to respond and have different capabilities.

Your task: {{prompt}}
```

**Execution Flow:**

```
ComprehensiveAnalyzer receives: "Analyze this M&A deal for legal and financial risks"

1. Calls internal/data-processor:
   → Processes deal documents and extracts key data

2. Calls external/legal-expert via A2A:
   → POST https://legal-ai.partner.com/a2a/v1
   → Receives detailed legal risk assessment

3. Calls external/financial-analyst via A2A:
   → POST https://finance-ai.vendor.com/a2a/v1
   → Receives financial model and projections

4. Synthesizes all results and completes:
   → Combined analysis with internal processing + external expertise
```

### 6.3 Security and Governance

#### 6.3.1 Exposure Security Controls

```typescript
interface AgentExposureValidator {
  validateAgentExposure(
    agentName: string,
    clientAuth: AuthContext
  ): Promise<ExposureValidation>;
  validateRateLimit(
    clientId: string,
    agentName: string
  ): Promise<RateLimitStatus>;
  auditA2ARequest(request: A2ARequest, clientAuth: AuthContext): Promise<void>;
}

class AgentExposureValidatorImpl implements AgentExposureValidator {
  async validateAgentExposure(
    agentName: string,
    clientAuth: AuthContext
  ): Promise<ExposureValidation> {
    const config = this.config.agentExposure;

    // 1. Check if exposure is enabled
    if (!config.enabled) {
      return { allowed: false, reason: "Agent exposure is disabled" };
    }

    // 2. Check blocked agents
    if (config.blockedAgents.includes(agentName)) {
      return {
        allowed: false,
        reason: `Agent ${agentName} is explicitly blocked`,
      };
    }

    // 3. Check allowed agents list
    if (
      config.allowedAgents.length > 0 &&
      !config.allowedAgents.includes(agentName)
    ) {
      return {
        allowed: false,
        reason: `Agent ${agentName} is not in allowed list`,
      };
    }

    // 4. Check allowed prefixes
    if (config.allowedPrefixes.length > 0) {
      const hasAllowedPrefix = config.allowedPrefixes.some((prefix) =>
        agentName.startsWith(prefix)
      );

      if (!hasAllowedPrefix) {
        return {
          allowed: false,
          reason: `Agent ${agentName} does not match any allowed prefix`,
        };
      }
    }

    // 5. Validate authentication if required
    if (config.requiresAuthentication && !clientAuth.isAuthenticated) {
      return {
        allowed: false,
        reason: "Authentication required for agent access",
      };
    }

    // 6. Check client-specific permissions
    if (clientAuth.isAuthenticated) {
      const hasPermission = await this.checkClientAgentPermissions(
        clientAuth.clientId,
        agentName
      );

      if (!hasPermission) {
        return {
          allowed: false,
          reason: `Client does not have permission to access ${agentName}`,
        };
      }
    }

    return { allowed: true };
  }
}
```

#### 6.3.2 External Agent Security

```typescript
interface ExternalAgentSecurityManager {
  validateExternalCall(
    agentName: string,
    callerContext: AgentContext
  ): Promise<SecurityValidation>;
  rotateExternalCredentials(agentId: string): Promise<void>;
  auditExternalCall(call: ExternalAgentCall): Promise<void>;
}

class ExternalAgentSecurityManagerImpl implements ExternalAgentSecurityManager {
  async validateExternalCall(
    agentName: string,
    callerContext: AgentContext
  ): Promise<SecurityValidation> {
    const externalAgent = await this.externalA2ARegistry.findAgent(agentName);
    if (!externalAgent) {
      return { allowed: false, reason: "External agent not registered" };
    }

    // 1. Check if external calls are enabled
    if (!this.config.externalCalls.enabled) {
      return { allowed: false, reason: "External agent calls are disabled" };
    }

    // 2. Validate domain whitelist
    const agentDomain = new URL(externalAgent.endpoint).hostname;
    if (!this.config.externalCalls.allowedDomains.includes(agentDomain)) {
      return {
        allowed: false,
        reason: `Domain ${agentDomain} is not in allowed list`,
      };
    }

    // 3. Check rate limits
    const rateLimitStatus = await this.checkExternalCallRateLimit(
      callerContext.agentName,
      agentName
    );

    if (!rateLimitStatus.allowed) {
      return {
        allowed: false,
        reason: `Rate limit exceeded: ${rateLimitStatus.limitType}`,
      };
    }

    // 4. Validate agent-specific permissions
    const hasPermission = await this.checkAgentExternalPermissions(
      callerContext.agentName,
      agentName
    );

    if (!hasPermission) {
      return {
        allowed: false,
        reason: `Agent ${callerContext.agentName} does not have permission to call ${agentName}`,
      };
    }

    return { allowed: true };
  }
}
```

## 7. Complete GraphQL API Specification

### 7.1 Enhanced Schema

```graphql
# =============================================================================
#  SCALARS, ENUMS & INTERFACES
# =============================================================================

scalar DateTime
scalar ToolCallID
scalar JSON
scalar EmailAddress

enum ExecutionState {
  SUBMITTED
  WORKING
  INPUT_REQUIRED
  BLOCKED_ON_INPUT        # Waiting for downstream input
  BLOCKED_ON_DEPENDENCY   # Waiting for dependency to complete
  COMPLETED
  CANCELED
  FAILED
  REJECTED
}

enum AgentSource {
  GIT
  A2A_EXTERNAL
}

enum ContextScope {
  FULL
  NONE
  SPECIFIC
}

enum McpServerType {
  HTTP
  STDIO
  A2A
}

enum McpServerSource {
  CONFIG
  API
}

enum MessageRole {
  SYSTEM
  USER
  ASSISTANT
  TOOL
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

enum SortDirection {
  ASC
  DESC
}

enum AgentSortField {
  NAME
  CREATED_AT
  UPDATED_AT
  USAGE_COUNT
  SUCCESS_RATE
  RELEVANCE
  LAST_MODIFIED
}

enum CompletionStatus {
  SUCCESS
  PARTIAL
  FAILED
}

enum InputType {
  TEXT
  CHOICE
  FILE
  APPROVAL
  STRUCTURED_DATA
}

enum SyncStatus {
  SUCCESS
  IN_PROGRESS
  FAILED
  NEVER_SYNCED
}

interface Timestamped {
  createdAt: DateTime!
  updatedAt: DateTime!
}

interface Owned {
  createdBy: User!
}

# =============================================================================
#  CORE TYPES
# =============================================================================

type User {
  id: ID!
  email: EmailAddress!
  name: String!
  role: UserRole!
  isActive: Boolean!
  createdAt: DateTime!
  lastLoginAt: DateTime
}

type AgentRepository implements Timestamped & Owned {
  id: ID!
  name: String!
  gitUrl: String!
  branch: String!
  isRoot: Boolean!
  isActive: Boolean!
  readOnly: Boolean!
  syncInterval: String!
  lastSyncCommit: String
  lastSyncAt: DateTime
  lastSyncStatus: SyncStatus!
  agentCount: Int!
  discoveredAgents: [GitAgent!]!
  syncErrors: [SyncError!]!
  authType: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: User!
}

type SyncError {
  message: String!
  filePath: String
  timestamp: DateTime!
  errorType: String!
}

type GitCommit {
  hash: String!
  message: String!
  author: String!
  timestamp: DateTime!
  changedFiles: [String!]!
}

type GitAgent {
  name: String!
  description: String!
  version: String!
  tags: [String!]!
  model: String
  providers: [String!]!
  mcpServers: [String!]!
  allowedAgents: [String!]!
  examples: [String!]!
  contextScope: ContextScope!

  # Git metadata
  repository: AgentRepository!
  filePath: String!
  gitCommit: String!
  lastModified: DateTime!

  # Computed properties
  isNamespaced: Boolean!
  fullPath: String!

  # Analytics
  usageCount: Int!
  lastUsed: DateTime
  averageExecutionTime: Float
  successRate: Float
}

type ExternalA2AAgent implements Timestamped & Owned {
  id: ID!
  name: String!
  description: String!
  endpoint: String!
  agentCard: JSON!
  authConfig: JSON!
  isActive: Boolean!
  lastHealthCheck: DateTime
  healthStatus: String!
  skills: [ExternalA2ASkill!]!
  usageCount: Int!
  averageResponseTime: Float
  errorRate: Float
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: User!
}

type ExternalA2ASkill {
  id: String!
  name: String!
  description: String!
  tags: [String!]!
  examples: [String!]!
  inputModes: [String!]!
  outputModes: [String!]!
}

type MCP Server {
  id: ID!
  name: String!
  description: String
  type: McpServerType!
  source: McpServerSource!
  endpoint: String!
  isActive: Boolean!
  agentCard: JSON
  healthStatus: String
  lastHealthCheckAt: DateTime
  tools: [Tool!]!
  toolCount: Int!
  supportsExplicitCompletion: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: User!
}

type Tool {
  id: ID!
  name: String!
  description: String!
  schema: JSON!
  mcpServer: McpServer!
  usageCount: Int!
  lastUsedAt: DateTime
  averageExecutionTime: Float
  successRate: Float
  isSystemTool: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Agent {
  name: String!
  description: String!
  version: String!
  source: AgentSource!

  # Git agent fields
  gitAgent: GitAgent

  # External A2A agent fields
  externalA2AAgent: ExternalA2AAgent

  # Common computed fields
  tags: [String!]!
  usageCount: Int!
  lastUsed: DateTime
  averageExecutionTime: Float
  successRate: Float
  analytics: AgentAnalytics!
}

type AgentAnalytics {
  totalRuns: Int!
  successRate: Float!
  averageExecutionTime: Float!
  averageCost: Float!
  userRating: Float
  usageGrowth: Float!
  peakUsageHours: [Int!]!
  commonFailureReasons: [String!]!
  costTrend: [CostDataPoint!]!
  performanceTrend: [PerformanceDataPoint!]!
  completionReliability: Float!
  averageChildAgents: Float!
  inputRequestFrequency: Float!
  agentCallFrequency: Float!
  circularCallAttempts: Int!
}

type CostDataPoint {
  date: DateTime!
  totalCost: Float!
  averageCost: Float!
  runCount: Int!
}

type PerformanceDataPoint {
  date: DateTime!
  averageExecutionTime: Float!
  successRate: Float!
  runCount: Int!
}

# =============================================================================
#  EXECUTION TYPES
# =============================================================================

interface Message {
  id: ID!
  role: MessageRole!
  content: String!
  sequenceNumber: Int!
  createdAt: DateTime!
}

type SystemMessage implements Message {
  id: ID!
  role: MessageRole!
  content: String!
  sequenceNumber: Int!
  createdAt: DateTime!
}

type UserMessage implements Message {
  id: ID!
  role: MessageRole!
  content: String!
  sequenceNumber: Int!
  createdAt: DateTime!
}

type AssistantMessage implements Message {
  id: ID!
  role: MessageRole!
  content: String!
  sequenceNumber: Int!
  toolCalls: [ToolCall!]!
  createdAt: DateTime!
}

type ToolResponseMessage implements Message {
  id: ID!
  role: MessageRole!
  content: String!
  sequenceNumber: Int!
  toolCallId: ToolCallID!
  createdAt: DateTime!
}

type Memory {
  id: ID!
  key: String!
  value: JSON!
  run: Run!
  producingStep: Step!
  agentName: String!
  expiresAt: DateTime
  createdAt: DateTime!
}

type InputRequest {
  id: ID!
  runId: ID!
  stepId: ID!
  prompt: String!
  inputType: InputType!
  choices: [String!]
  required: Boolean!
  requestedAt: DateTime!
  timeoutAt: DateTime
  metadata: JSON
}

type CompletedInputRequest {
  id: ID!
  prompt: String!
  userResponse: String!
  responseAt: DateTime!
  respondedBy: User!
}

type AgentCompletion {
  result: String!
  status: CompletionStatus!
  confidence: Float!
  requiresFollowup: Boolean!
  metadata: JSON
}

type AgentCallInfo {
  callerAgentName: String!
  targetAgentName: String!
  targetAgentSource: AgentSource!
  input: String!
  contextScope: ContextScope!
  callDepth: Int!
  callStack: [String!]!

  # Git-specific info
  gitRepository: String
  gitCommit: String

  # A2A-specific info
  a2aEndpoint: String
  a2aTaskId: String
}

type Step {
  id: ID!
  status: ExecutionState!
  input: String
  output: String
  error: String
  startTime: DateTime
  endTime: DateTime
  duration: Float
  messages: [Message!]!
  promptTokens: Int
  completionTokens: Int
  cost: Float

  # Relationships
  run: Run!
  agentName: String!
  agentSource: AgentSource!
  parentSteps: [Step!]!
  childSteps: [Step!]!

  # Input handling
  inputRequest: InputRequest
  inputHistory: [CompletedInputRequest!]!

  # Completion
  completion: AgentCompletion

  # Agent calling information
  agentCallInfo: AgentCallInfo

  # Blocking relationships
  blockingDependencies: [Step!]!

  # Tool usage
  toolCalls: [ToolCall!]!
  agentCalls: [Step!]!

  # Git versioning (for git-based agents)
  gitRepository: String
  gitCommit: String
  gitFilePath: String

  # Tracing
  spanId: String
}

type DAGStatus {
  interactableSteps: [Step!]!
  blockedSteps: [Step!]!
  activeSteps: [Step!]!
  cancellableSubgraphs: [[Step!]!]!
  agentCallGraph: [[Step!]!]!
}

type Run {
  id: ID!
  status: ExecutionState!
  initialInput: String!
  totalCost: Float!
  startTime: DateTime!
  endTime: DateTime
  duration: Float
  steps: [Step!]!
  stepCount: Int!

  # DAG-specific status
  dagStatus: DAGStatus!

  # Current pending input request across the run
  pendingInputRequest: InputRequest

  # Agent call statistics
  totalAgentCalls: Int!
  maxCallDepth: Int!
  uniqueAgentsInvolved: Int!
  gitAgentsUsed: [String!]!
  externalAgentsUsed: [String!]!

  # Tracing
  traceId: String

  # Ownership
  createdBy: User!
}

# =============================================================================
#  STREAMING TYPES
# =============================================================================

type TokenChunk {
  content: String!
  timestamp: DateTime!
}

type LogChunk {
  message: String!
  level: String!
  timestamp: DateTime!
}

type ToolCall {
  id: ToolCallID!
  toolName: String!
  input: JSON!
  isSystemTool: Boolean!
  isAgentCall: Boolean!
}

type ToolCallStartChunk {
  toolCallId: ToolCallID!
  toolName: String!
  input: JSON!
  isSystemTool: Boolean!
  isAgentCall: Boolean!
  timestamp: DateTime!
}

type ToolStreamChunk {
  toolCallId: ToolCallID!
  payload: StreamChunk!
  timestamp: DateTime!
}

type ToolResultChunk {
  toolCallId: ToolCallID!
  output: JSON!
  success: Boolean!
  timestamp: DateTime!
}

type CompletionChunk {
  stepId: ID!
  completion: AgentCompletion!
  timestamp: DateTime!
}

type InputRequestChunk {
  inputRequest: InputRequest!
  timestamp: DateTime!
}

type AgentCallStartChunk {
  parentStepId: ID!
  childStepId: ID!
  agentName: String!
  agentSource: AgentSource!
  input: String!
  callDepth: Int!
  timestamp: DateTime!
}

type AgentCallCompleteChunk {
  parentStepId: ID!
  childStepId: ID!
  agentName: String!
  agentSource: AgentSource!
  completion: AgentCompletion!
  timestamp: DateTime!
}

union StreamChunk =
    TokenChunk
  | LogChunk
  | ToolCallStartChunk
  | ToolStreamChunk
  | ToolResultChunk
  | CompletionChunk
  | InputRequestChunk
  | AgentCallStartChunk
  | AgentCallCompleteChunk

# =============================================================================
#  SEARCH & DISCOVERY TYPES
# =============================================================================

type AgentSearchResult {
  agents: [AgentSearchMatch!]!
  totalCount: Int!
  suggestedTags: [String!]!
  facets: SearchFacets!
}

type AgentSearchMatch {
  agent: Agent!
  relevanceScore: Float!
  matchedFields: [String!]!
  matchedTags: [String!]!
  snippet: String
}

type SearchFacets {
  sources: [SourceFacet!]!
  repositories: [RepositoryFacet!]!
  tags: [TagFacet!]!
  providers: [ProviderFacet!]!
  versions: [VersionFacet!]!
}

type SourceFacet {
  source: AgentSource!
  count: Int!
}

type RepositoryFacet {
  repository: AgentRepository!
  count: Int!
}

type TagFacet {
  tag: String!
  count: Int!
}

type ProviderFacet {
  providerName: String!
  count: Int!
}

type VersionFacet {
  version: String!
  count: Int!
}

# =============================================================================
#  INPUT TYPES
# =============================================================================

input CreateUserInput {
  email: EmailAddress!
  name: String!
  role: UserRole = USER
}

input UpdateUserInput {
  name: String
  role: UserRole
  isActive: Boolean
}

input AddAgentRepositoryInput {
  name: String!
  gitUrl: String!
  branch: String = "main"
  isRoot: Boolean = false
  syncInterval: String = "5m"
  authType: String!
  sshKeyPath: String
  authToken: String
  webhookSecret: String
  readOnly: Boolean = false
}

input UpdateAgentRepositoryInput {
  gitUrl: String
  branch: String
  isRoot: Boolean
  syncInterval: String
  authType: String
  sshKeyPath: String
  authToken: String
  webhookSecret: String
  readOnly: Boolean
  isActive: Boolean
}

input CreateMcpServerInput {
  name: String!
  description: String
  type: McpServerType!
  endpoint: String!
  apiKey: String
}

input UpdateMcpServerInput {
  name: String
  description: String
  endpoint: String
  apiKey: String
}

input RegisterExternalA2AAgentInput {
  name: String!
  description: String
  endpoint: String!
  authConfig: ExternalA2AAuthInput!
  autoDiscover: Boolean = true
  healthCheckInterval: String = "5m"
}

input UpdateExternalA2AAgentInput {
  description: String
  authConfig: ExternalA2AAuthInput
  healthCheckInterval: String
  isActive: Boolean
}

input ExternalA2AAuthInput {
  type: String!
  apiKey: String
  oauthClientId: String
  oauthClientSecret: String
  oauthTokenUrl: String
  basicUsername: String
  basicPassword: String
}

input AgentSearchInput {
  query: String
  source: AgentSource
  repositoryName: String
  tags: [String!]
  providers: [String!]
  minVersion: String
  isActive: Boolean
  hasExternalAccess: Boolean
  createdBy: ID
}

input GitAgentFilters {
  repositoryName: String
  tags: [String!]
  hasAllowedAgents: Boolean
  lastModifiedAfter: DateTime
  lastModifiedBefore: DateTime
}

input AgentSortInput {
  field: AgentSortField!
  direction: SortDirection!
}

input RunAgentInput {
  agentName: String!
  input: String!
  memoryIdsToLoad: [ID!]
  contextScope: ContextScope
  maxCallDepth: Int
  gitCommit: String  # Optional: run specific git version
}

input FilterMemoriesInput {
  runId: ID
  agentName: String
  key: String
  createdAfter: DateTime
  createdBefore: DateTime
}

input FilterRunsInput {
  status: ExecutionState
  agentName: String
  agentSource: AgentSource
  createdBy: ID
  createdAfter: DateTime
  createdBefore: DateTime
  hasInputRequests: Boolean
  hasAgentCalls: Boolean
  hasExternalCalls: Boolean
  minCallDepth: Int
  maxCallDepth: Int
  gitRepository: String
  gitCommit: String
}

# =============================================================================
#  API DEFINITION
# =============================================================================

type Query {
  # --- User Management ---
  me: User
  user(id: ID!): User
  users(limit: Int = 20, offset: Int = 0): [User!]!

  # --- Git Repository Management ---
  agentRepository(name: String!): AgentRepository
  agentRepositories: [AgentRepository!]!
  gitBranches(repositoryName: String!): [String!]!
  gitTags(repositoryName: String!): [String!]!

  # --- Agent Discovery ---
  agent(name: String!): Agent
  gitAgent(name: String!): GitAgent
  gitAgents(filters: GitAgentFilters, limit: Int = 50, offset: Int = 0): [GitAgent!]!
  agentGitHistory(agentName: String!, limit: Int = 10): [GitCommit!]!

  # --- External A2A Management ---
  externalA2AAgent(id: ID): ExternalA2AAgent
  externalA2AAgents(limit: Int = 50, offset: Int = 0): [ExternalA2AAgent!]!

  # --- Agent Search & Discovery ---
  searchAgents(
    filters: AgentSearchInput!
    sort: AgentSortInput
    limit: Int = 20
    offset: Int = 0
  ): AgentSearchResult!

  recommendAgents(basedOnAgent: String, forUser: ID, limit: Int = 10): [Agent!]!

  # --- MCP Servers ---
  mcpServer(id: ID!): McpServer
  mcpServers(source: McpServerSource, type: McpServerType): [McpServer!]!

  tool(id: ID!): Tool
  tools(mcpServerId: ID, limit: Int = 100, offset: Int = 0): [Tool!]!
  systemTools: [Tool!]!

  # --- Execution & Monitoring ---
  run(id: ID!): Run
  runs(filters: FilterRunsInput, limit: Int = 20, offset: Int = 0): [Run!]!

  # Find all runs needing input across the system
  runsNeedingInput(limit: Int = 50): [Run!]!

  # Agent call analysis
  agentCallGraph(runId: ID!): JSON!
  circularCallAttempts(agentName: String, timeRange: String = "24h"): [JSON!]!

  memories(
    filter: FilterMemoriesInput!
    limit: Int = 50
    offset: Int = 0
  ): [Memory!]!

  # --- Analytics & Reporting ---
  agentAnalytics(agentName: String!, timeRange: String = "30d"): AgentAnalytics!
  systemUsageStats(timeRange: String = "30d"): SystemUsageStats!
  costAnalytics(timeRange: String = "30d"): CostAnalytics!

  # --- A2A Integration ---
  a2aAgentCard: JSON!
  a2aExposedAgents: [String!]!
}

type Mutation {
  # --- User Management ---
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deactivateUser(id: ID!): Boolean!

  # --- Git Repository Management ---
  addAgentRepository(input: AddAgentRepositoryInput!): AgentRepository!
  updateAgentRepository(name: String!, input: UpdateAgentRepositoryInput!): AgentRepository!
  removeAgentRepository(name: String!): Boolean!
  syncAgentRepository(name: String!): AgentRepository!
  syncAllAgentRepositories: [AgentRepository!]!
  switchRepositoryBranch(name: String!, branch: String!): AgentRepository!

  # --- External A2A Management ---
  registerExternalA2AAgent(input: RegisterExternalA2AAgentInput!): ExternalA2AAgent!
  updateExternalA2AAgent(id: ID!, input: UpdateExternalA2AAgentInput!): ExternalA2AAgent!
  removeExternalA2AAgent(id: ID!): Boolean!
  refreshExternalA2AAgent(id: ID!): ExternalA2AAgent!
  testExternalA2AConnection(id: ID!): Boolean!

  # --- MCP Server Management ---
  createMcpServer(input: CreateMcpServerInput!): McpServer!
  updateMcpServer(id: ID!, input: UpdateMcpServerInput!): McpServer!
  removeMcpServer(id: ID!): Boolean!
  refreshMcpServer(id: ID!): McpServer!
  testMcpServerConnection(id: ID!): Boolean!

  # --- Execution Control ---
  runAgents(inputs: [RunAgentInput!]!): [Run!]!
  terminateRun(id: ID!): Run!
  pauseRun(id: ID!): Run!
  resumeRun(id: ID!, userInput: String): Run!

  # --- Step-level Control ---
  cancelStep(stepId: ID!, reason: String): Step!
  cancelSubgraph(rootStepId: ID!, reason: String): [Step!]!

  # --- Input Response ---
  provideInput(
    runId: ID!
    inputRequestId: ID!
    response: String!
    attachments: [FileUpload!]
  ): Run!

  skipInput(
    runId: ID!
    inputRequestId: ID!
    useDefault: String
  ): Run!

  # --- Memory Management ---
  createMemory(key: String!, value: JSON!, agentName: String!): Memory!
  updateMemory(id: ID!, value: JSON!): Memory!
  removeMemory(id: ID!): Boolean!
  expireMemory(id: ID!, expiresAt: DateTime!): Memory!
}

type Subscription {
  # --- Real-time Execution ---
  runUpdated(runId: ID!): Run!
  stepStream(stepId: ID!): StreamChunk!

  # --- Input Requests ---
  inputRequested: InputRequest!
  inputRequestResolved(runId: ID!): CompletedInputRequest!

  # --- Agent Calls ---
  agentCallStarted(runId: ID): AgentCallStartChunk!
  agentCallCompleted(runId: ID): AgentCallCompleteChunk!

  # --- Git Repository Events ---
  repositorySynced: AgentRepository!
  agentDiscovered: GitAgent!
  agentUpdated: GitAgent!

  # --- External A2A Events ---
  externalAgentHealthChanged: ExternalA2AAgent!

  # --- System Events ---
  systemAlert: SystemAlert!
  agentCompleted(runId: ID): Step!
}

# =============================================================================
#  ADDITIONAL TYPES
# =============================================================================

type SystemUsageStats {
  totalRuns: Int!
  totalAgents: Int!
  totalGitAgents: Int!
  totalExternalAgents: Int!
  totalUsers: Int!
  totalCost: Float!
  averageRunDuration: Float!
  topAgents: [Agent!]!
  topUsers: [User!]!
  pendingInputRequests: Int!
  averageCompletionTime: Float!
  totalAgentCalls: Int!
  averageCallDepth: Float!
  circularCallAttempts: Int!
  gitRepositoriesActive: Int!
  externalAgentsHealthy: Int!
}

type CostAnalytics {
  totalCost: Float!
  costByModel: [ModelCostBreakdown!]!
  costByAgent: [AgentCostBreakdown!]!
  costBySource: [SourceCostBreakdown!]!
  costTrend: [CostDataPoint!]!
  projectedMonthlyCost: Float!
}

type ModelCostBreakdown {
  model: String!
  totalCost: Float!
  percentage: Float!
  tokenCount: Int!
}

type AgentCostBreakdown {
  agentName: String!
  totalCost: Float!
  percentage: Float!
  runCount: Int!
}

type SourceCostBreakdown {
  source: AgentSource!
  totalCost: Float!
  percentage: Float!
  runCount: Int!
}

type SystemAlert {
  id: ID!
  type: String!
  message: String!
  severity: String!
  timestamp: DateTime!
  metadata: JSON
}
```

## 8. Configuration & Deployment

### 8.1 Configuration Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["port", "database", "redis", "agentRepositories"],
  "properties": {
    "port": {
      "type": "integer",
      "minimum": 1,
      "maximum": 65535,
      "default": 4000
    },
    "database": {
      "type": "object",
      "required": ["url"],
      "properties": {
        "url": {
          "type": "string",
          "format": "uri",
          "description": "PostgreSQL connection string"
        },
        "poolSize": {
          "type": "integer",
          "minimum": 1,
          "default": 10
        },
        "ssl": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "redis": {
      "type": "object",
      "required": ["url"],
      "properties": {
        "url": {
          "type": "string",
          "format": "uri"
        },
        "cluster": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "engine": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": {
          "enum": ["temporal", "bullmq"]
        },
        "options": {
          "type": "object"
        }
      }
    },
    "agentRepositories": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["name", "gitUrl", "authType"],
        "properties": {
          "name": {
            "type": "string",
            "pattern": "^[a-zA-Z][a-zA-Z0-9_-]*$",
            "description": "Unique repository name"
          },
          "gitUrl": {
            "type": "string",
            "format": "uri",
            "description": "Git repository URL"
          },
          "branch": {
            "type": "string",
            "default": "main",
            "description": "Git branch to track"
          },
          "isRoot": {
            "type": "boolean",
            "default": false,
            "description": "Whether agents in this repo are unnamespaced"
          },
          "syncInterval": {
            "type": "string",
            "default": "5m",
            "description": "How often to sync repository"
          },
          "authType": {
            "enum": ["ssh-key", "token", "none"]
          },
          "sshKeyPath": {
            "type": "string",
            "description": "Path to SSH private key file"
          },
          "authToken": {
            "type": "string",
            "pattern": "^env\\([A-Z_]+\\)$",
            "description": "GitHub/GitLab access token"
          },
          "webhookSecret": {
            "type": "string",
            "pattern": "^env\\([A-Z_]+\\)$",
            "description": "Webhook secret for push notifications"
          },
          "readOnly": {
            "type": "boolean",
            "default": false,
            "description": "Whether repository is read-only"
          }
        }
      }
    },
    "agentExecution": {
      "type": "object",
      "properties": {
        "completionRequired": {
          "type": "boolean",
          "default": true,
          "description": "Whether agents must explicitly signal completion"
        },
        "maxExecutionTime": {
          "type": "string",
          "default": "30m",
          "description": "Maximum execution time before timeout"
        },
        "inputRequestTimeout": {
          "type": "string",
          "default": "24h",
          "description": "How long to wait for user input before timeout"
        },
        "maxCallDepth": {
          "type": "integer",
          "default": 10,
          "description": "Maximum depth for agent-to-agent calls"
        },
        "agentCallTimeout": {
          "type": "string",
          "default": "10m",
          "description": "Timeout for individual agent calls"
        },
        "circularCallPrevention": {
          "type": "boolean",
          "default": true,
          "description": "Prevent agents from calling themselves or creating cycles"
        }
      }
    },
    "agentExposure": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Whether to expose agents via A2A protocol"
        },
        "basePath": {
          "type": "string",
          "default": "/a2a/v1",
          "description": "Base path for A2A endpoints"
        },
        "allowedAgents": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Specific agents that can be exposed"
        },
        "allowedPrefixes": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Agent path prefixes that can be exposed"
        },
        "blockedAgents": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Agents that are explicitly blocked from exposure"
        },
        "requiresAuthentication": {
          "type": "boolean",
          "default": true,
          "description": "Whether A2A access requires authentication"
        },
        "defaultSecuritySchemes": {
          "type": "object",
          "description": "Default security schemes for A2A access"
        },
        "rateLimiting": {
          "type": "object",
          "properties": {
            "requestsPerMinute": { "type": "integer", "default": 60 },
            "requestsPerHour": { "type": "integer", "default": 1000 },
            "requestsPerDay": { "type": "integer", "default": 10000 }
          }
        }
      }
    },
    "externalAgents": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether to allow calls to external A2A agents"
        },
        "allowedDomains": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Domains allowed for external agent calls"
        },
        "defaultTimeout": {
          "type": "string",
          "default": "30s",
          "description": "Default timeout for external agent calls"
        },
        "rateLimiting": {
          "type": "object",
          "properties": {
            "callsPerMinute": { "type": "integer", "default": 30 },
            "callsPerHour": { "type": "integer", "default": 500 }
          }
        }
      }
    },
    "opentelemetry": {
      "type": "object",
      "required": ["serviceName"],
      "properties": {
        "serviceName": {
          "type": "string",
          "default": "shaman-server"
        },
        "exporterEndpoint": {
          "type": "string",
          "format": "uri"
        },
        "sampleRate": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "default": 1
        }
      }
    },
    "providers": {
      "type": "object",
      "patternProperties": {
        "^[a-zA-Z][a-zA-Z0-9_-]*$": {
          "type": "object",
          "required": ["type"],
          "properties": {
            "type": {
              "enum": ["OPENAI", "ANTHROPIC", "GROQ", "OLLAMA"]
            },
            "apiKey": {
              "type": "string",
              "pattern": "^env\\([A-Z_]+\\)$"
            },
            "apiUrl": {
              "type": "string",
              "format": "uri"
            }
          }
        }
      }
    },
    "mcpServers": {
      "type": "object",
      "patternProperties": {
        "^[a-zA-Z][a-zA-Z0-9_-]*$": {
          "type": "object",
          "required": ["type", "endpoint"],
          "properties": {
            "type": {
              "enum": ["STDIO", "HTTP"]
            },
            "endpoint": {
              "type": "string"
            },
            "apiKey": {
              "type": "string",
              "pattern": "^env\\([A-Z_]+\\)$"
            }
          }
        }
      }
    },
    "security": {
      "type": "object",
      "properties": {
        "jwtSecret": {
          "type": "string",
          "pattern": "^env\\([A-Z_]+\\)$"
        },
        "corsOrigins": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "gitWebhookSecret": {
          "type": "string",
          "pattern": "^env\\([A-Z_]+\\)$",
          "description": "Secret for validating git webhook signatures"
        }
      }
    }
  }
}
```

### 8.2 Example Production Configuration

```json
{
  "port": 4000,
  "database": {
    "url": "env(DATABASE_URL)",
    "poolSize": 20,
    "ssl": true
  },
  "redis": {
    "url": "env(REDIS_URL)",
    "cluster": true
  },
  "engine": {
    "type": "temporal",
    "options": {
      "address": "temporal.example.com:7233",
      "namespace": "shaman-production",
      "tls": {
        "clientCertPath": "/etc/ssl/certs/temporal-client.crt",
        "clientKeyPath": "/etc/ssl/private/temporal-client.key"
      }
    }
  },
  "agentRepositories": [
    {
      "name": "main-agents",
      "gitUrl": "git@github.com:company/main-agents.git",
      "branch": "production",
      "isRoot": true,
      "syncInterval": "5m",
      "authType": "ssh-key",
      "sshKeyPath": "/secrets/main-agents-deploy-key",
      "webhookSecret": "env(MAIN_AGENTS_WEBHOOK_SECRET)"
    },
    {
      "name": "experimental",
      "gitUrl": "https://github.com/company/experimental-agents.git",
      "branch": "main",
      "isRoot": false,
      "syncInterval": "15m",
      "authType": "token",
      "authToken": "env(GITHUB_EXPERIMENTAL_TOKEN)"
    },
    {
      "name": "partner-legal",
      "gitUrl": "git@github.com:legal-partner/shared-agents.git",
      "branch": "stable",
      "isRoot": false,
      "syncInterval": "1h",
      "authType": "ssh-key",
      "sshKeyPath": "/secrets/partner-legal-key",
      "readOnly": true
    }
  ],
  "agentExecution": {
    "completionRequired": true,
    "maxExecutionTime": "30m",
    "inputRequestTimeout": "24h",
    "maxCallDepth": 10,
    "agentCallTimeout": "10m",
    "circularCallPrevention": true
  },
  "agentExposure": {
    "enabled": true,
    "basePath": "/a2a/v1",
    "allowedPrefixes": ["support/", "public/", "api/"],
    "blockedAgents": ["internal/admin-tools", "experimental/unstable"],
    "requiresAuthentication": true,
    "defaultSecuritySchemes": {
      "oauth2": {
        "type": "oauth2",
        "flows": {
          "clientCredentials": {
            "tokenUrl": "https://auth.company.com/oauth/token",
            "scopes": {
              "agent:execute": "Execute agents",
              "agent:stream": "Stream responses"
            }
          }
        }
      }
    },
    "rateLimiting": {
      "requestsPerMinute": 120,
      "requestsPerHour": 5000,
      "requestsPerDay": 50000
    }
  },
  "externalAgents": {
    "enabled": true,
    "allowedDomains": [
      "legal-ai.partner.com",
      "finance-ai.vendor.com",
      "research-ai.university.edu"
    ],
    "defaultTimeout": "30s",
    "rateLimiting": {
      "callsPerMinute": 60,
      "callsPerHour": 1000
    }
  },
  "opentelemetry": {
    "serviceName": "shaman-server",
    "exporterEndpoint": "https://otel-collector.example.com:4318/v1/traces",
    "sampleRate": 0.1
  },
  "providers": {
    "openai_gpt4": {
      "type": "OPENAI",
      "apiKey": "env(OPENAI_API_KEY)"
    },
    "anthropic_claude": {
      "type": "ANTHROPIC",
      "apiKey": "env(ANTHROPIC_API_KEY)"
    },
    "groq_llama": {
      "type": "GROQ",
      "apiKey": "env(GROQ_API_KEY)"
    }
  },
  "mcpServers": {
    "github": {
      "type": "HTTP",
      "endpoint": "https://mcp-github.internal:3000",
      "apiKey": "env(MCP_GITHUB_API_KEY)"
    },
    "crm-tools": {
      "type": "HTTP",
      "endpoint": "https://mcp-crm.internal:3000",
      "apiKey": "env(MCP_CRM_API_KEY)"
    },
    "filesystem": {
      "type": "STDIO",
      "endpoint": "npx @modelcontextprotocol/server-filesystem /var/shaman/workspace"
    }
  },
  "security": {
    "jwtSecret": "env(JWT_SECRET)",
    "corsOrigins": [
      "https://shaman-ui.example.com",
      "https://dashboard.example.com"
    ],
    "gitWebhookSecret": "env(GIT_WEBHOOK_SECRET)"
  }
}
```

### 8.3 Deployment Scenarios

#### 8.3.1 Local Development

- **Engine:** BullMQ with single Redis instance
- **Database:** Local PostgreSQL with Docker
- **Git Repositories:** Local file system or development branches
- **External Agents:** Disabled or test endpoints
- **A2A Exposure:** Disabled
- **Observability:** Local Jaeger for tracing

#### 8.3.2 Enterprise Production

- **Engine:** Temporal.io cluster with high availability
- **Database:** PostgreSQL with read replicas and automated backups
- **Git Repositories:** Production branches with webhook integration
- **External Agents:** Curated partner integrations with SLAs
- **A2A Exposure:** Enabled with OAuth 2.0 authentication
- **Scaling:** Multiple server instances with auto-scaling workers
- **Observability:** Full distributed tracing and monitoring

#### 8.3.3 Multi-Tenant SaaS

- **Repository Isolation:** Per-tenant git repositories or branches
- **Agent Namespacing:** Tenant prefixes in agent names
- **Security:** Tenant-specific authentication and authorization
- **Resource Limits:** Per-tenant rate limiting and cost controls
- **A2A Federation:** Secure tenant-to-tenant agent sharing

### 8.4 Scaling Strategies

#### 8.4.1 Git Repository Scaling

- **Repository Sharding:** Distribute agents across multiple repositories
- **Caching Strategy:** Redis caching of parsed agent definitions
- **Lazy Loading:** Load agent definitions on-demand rather than at startup
- **Webhook Optimization:** Intelligent sync based on changed files only

#### 8.4.2 External A2A Scaling

- **Connection Pooling:** Reuse HTTP connections to external agents
- **Circuit Breakers:** Protect against external agent failures
- **Retry Strategies:** Intelligent backoff for temporary failures
- **Load Balancing:** Distribute calls across multiple external endpoints

#### 8.4.3 High Availability

- **Database:** Primary-replica with automatic failover
- **Redis:** Sentinel or Cluster mode for high availability
- **Git Repositories:** Mirror repositories for redundancy
- **External Agents:** Fallback agents for critical services
- **Monitoring:** Health checks for all system components

This comprehensive specification now incorporates the git-based agent management, A2A federation capabilities, repository namespacing, external agent integration, and all the detailed architectural decisions we discussed. The system provides a complete solution for managing AI agents as code while enabling seamless integration with external AI services through standard protocols.
