scalar DateTime
scalar EmailAddress

# =============================================================================
# ENUMS
# =============================================================================

enum ExecutionState {
  SUBMITTED
  WORKING
  INPUT_REQUIRED
  BLOCKED_ON_INPUT
  BLOCKED_ON_DEPENDENCY
  COMPLETED
  CANCELED
  FAILED
  REJECTED
}

enum AgentSource {
  GIT
  A2A_EXTERNAL
}

enum ContextScope {
  FULL
  NONE
  SPECIFIC
}

enum MessageRole {
  SYSTEM
  USER
  ASSISTANT
  TOOL
}

enum InputType {
  TEXT
  CHOICE
  FILE
  APPROVAL
  STRUCTURED_DATA
}

enum CompletionStatus {
  SUCCESS
  PARTIAL
  FAILED
}

enum SyncStatus {
  NEVER_SYNCED
  SUCCESS
  IN_PROGRESS
  FAILED
}

enum StepType {
  AGENT_EXECUTION
  LLM_CALL
  TOOL_CALL
  AGENT_CALL
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

enum McpServerType {
  HTTP
  STDIO
  A2A
}

enum McpAccessType {
  ALL_TOOLS
  SPECIFIC_TOOLS
  NO_ACCESS
}

enum StreamEventType {
  TOKEN
  LOG
  TOOL_CALL_START
  TOOL_STREAM
  TOOL_RESULT
  COMPLETION
  INPUT_REQUEST
  AGENT_CALL_START
  AGENT_CALL_COMPLETE
}

enum ErrorCode {
  VALIDATION_ERROR
  PARSE_ERROR
  CONNECTION_ERROR
  TIMEOUT_ERROR
  PERMISSION_ERROR
  NOT_FOUND_ERROR
  CONFLICT_ERROR
  INTERNAL_ERROR
}

# =============================================================================
# COMMON TYPES
# =============================================================================

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type ValidationError {
  field: String!
  message: String!
  code: String!
}

type ErrorContext {
  gitCommit: String
  agentName: String
  repositoryName: String
  filePath: String
  lineNumber: Int
  validationErrors: [ValidationError!]
}

type Error {
  code: ErrorCode!
  message: String!
  timestamp: DateTime!
  context: ErrorContext
}

# =============================================================================
# USER & AUTH TYPES
# =============================================================================

type User {
  id: ID!
  email: EmailAddress!
  name: String!
  role: UserRole!
  isActive: Boolean!
  createdAt: DateTime!
  lastLoginAt: DateTime
}

# =============================================================================
# REPOSITORY TYPES
# =============================================================================

type AgentRepository {
  id: ID!
  name: String!
  gitUrl: String!
  branch: String!
  isRoot: Boolean!
  isActive: Boolean!
  readOnly: Boolean!
  syncInterval: String!
  authType: String!
  
  # Sync status
  lastSyncCommitHash: String
  lastSyncAt: DateTime
  lastSyncStatus: SyncStatus!
  lastSyncErrors: [Error!]
  
  # Relationships
  agents(first: Int, after: String): GitAgentConnection!
  branches: [String!]!
  tags: [String!]!
  
  # Metadata
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: User!
}

# =============================================================================
# AGENT TYPES
# =============================================================================

type McpServerAccess {
  serverName: String!
  accessType: McpAccessType!
  allowedTools: [String!] # Only populated when accessType is SPECIFIC_TOOLS
}

type Agent {
  name: String!
  description: String!
  source: AgentSource!
  tags: [String!]!
  
  # Details based on source
  gitDetails: GitAgentDetails
  externalDetails: ExternalAgentDetails
  
  # Analytics
  usageCount: Int!
  lastUsed: DateTime
  averageExecutionTime: Float
  successRate: Float
}

type GitAgentDetails {
  version: String!
  repository: AgentRepository!
  filePath: String!
  gitCommit: String!
  lastModified: DateTime!
  
  # Configuration
  model: String
  providers: [String!]!
  mcpServers: [McpServerAccess!]!
  allowedAgents: [String!]!
  examples: [String!]!
  contextScope: ContextScope!
}

type ExternalAgentDetails {
  id: ID!
  endpoint: String!
  authType: String!
  isActive: Boolean!
  lastHealthCheck: DateTime
  healthStatus: String!
  skills: [ExternalAgentSkill!]!
  averageResponseTime: Float
  errorRate: Float
}

type ExternalAgentSkill {
  id: String!
  name: String!
  description: String!
  tags: [String!]!
  examples: [String!]!
  inputModes: [String!]!
  outputModes: [String!]!
}

# =============================================================================
# MCP SERVER & TOOL TYPES
# =============================================================================

type McpServer {
  id: ID!
  name: String!
  description: String
  type: McpServerType!
  endpoint: String!
  isActive: Boolean!
  healthStatus: String
  lastHealthCheckAt: DateTime
  
  # Relationships
  tools(first: Int, after: String): ToolConnection!
  
  # Metadata
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: User!
}

type Tool {
  id: ID!
  name: String!
  description: String!
  schema: ToolSchema!
  mcpServer: McpServer!
  isSystemTool: Boolean!
  
  # Analytics
  usageCount: Int!
  lastUsedAt: DateTime
  averageExecutionTime: Float
  successRate: Float
  
  # Metadata
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ToolSchema {
  inputSchema: InputSchema!
  outputSchema: OutputSchema
}

type InputSchema {
  type: String!
  properties: [PropertySchema!]!
  required: [String!]!
}

type OutputSchema {
  type: String!
  properties: [PropertySchema!]!
}

type PropertySchema {
  name: String!
  type: String!
  description: String
  format: String
  enum: [String!]
  items: PropertySchema
}

# =============================================================================
# EXECUTION TYPES
# =============================================================================

type Run {
  id: ID!
  status: ExecutionState!
  initialInput: String!
  totalCost: Float!
  startTime: DateTime!
  endTime: DateTime
  duration: Int # milliseconds
  
  # Relationships
  steps(first: Int, after: String, filter: StepFilter): StepConnection!
  workflowData(key: String): [WorkflowData!]!
  pendingInputRequests: [InputRequest!]!
  
  # DAG analysis
  dagStatus: DagStatus!
  
  # Metadata
  traceId: String
  createdBy: User!
}

type Step {
  id: ID!
  type: StepType!
  status: ExecutionState!
  agentName: String
  agentSource: AgentSource
  input: String
  output: String
  error: Error
  
  # Timing
  startTime: DateTime
  endTime: DateTime
  duration: Int # milliseconds
  
  # Relationships
  run: Run!
  parentStep: Step
  childSteps: [Step!]!
  messages: [Message!]!
  
  # Token usage
  promptTokens: Int
  completionTokens: Int
  cost: Float
  
  # Tool/Agent calls
  toolName: String
  toolCallId: String
  
  # Completion
  completion: AgentCompletion
  
  # Input handling
  inputRequest: InputRequest
}

type Message {
  id: ID!
  role: MessageRole!
  content: String!
  sequenceNumber: Int!
  createdAt: DateTime!
  
  # Optional fields based on role
  toolCallId: String # Present for TOOL role
  toolCalls: [ToolCall!] # Present for ASSISTANT role
}

type ToolCall {
  id: ID!
  toolName: String!
  input: ToolCallInput!
  isSystemTool: Boolean!
  isAgentCall: Boolean!
}

type ToolCallInput {
  parameters: [Parameter!]!
}

type Parameter {
  name: String!
  value: String!
  type: String!
}

type AgentCompletion {
  result: String!
  status: CompletionStatus!
  confidence: Float!
  requiresFollowup: Boolean!
  metadata: [MetadataField!]
}

type MetadataField {
  key: String!
  value: String!
}

type WorkflowData {
  id: ID!
  runId: String!
  key: String!
  value: WorkflowDataValue!
  createdByStepId: String!
  createdByAgentName: String!
  createdByAgentSource: AgentSource!
  createdAt: DateTime!
}

type WorkflowDataValue {
  type: String!
  data: String!
}

type InputRequest {
  id: ID!
  runId: String!
  stepId: String!
  prompt: String!
  inputType: InputType!
  choices: [String!]
  required: Boolean!
  requestedAt: DateTime!
  timeoutAt: DateTime
  
  # Response (if provided)
  userResponse: String
  responseAt: DateTime
  respondedBy: User
  
  # Metadata
  metadata: [MetadataField!]
}

type DagStatus {
  activeSteps: [Step!]!
  blockedSteps: [Step!]!
  completedSteps: [Step!]!
  totalSteps: Int!
  maxDepth: Int!
  criticalPath: [Step!]!
}

# =============================================================================
# STREAMING TYPES
# =============================================================================

type StreamEvent {
  id: ID!
  type: StreamEventType!
  timestamp: DateTime!
  stepId: ID!
  
  # Event-specific data (only one will be populated based on type)
  tokenData: TokenData
  logData: LogData
  toolCallStartData: ToolCallStartData
  toolStreamData: ToolStreamData
  toolResultData: ToolResultData
  completionData: CompletionData
  inputRequestData: InputRequestData
  agentCallStartData: AgentCallStartData
  agentCallCompleteData: AgentCallCompleteData
}

type TokenData {
  content: String!
}

type LogData {
  level: String!
  message: String!
}

type ToolCallStartData {
  toolCallId: ID!
  toolName: String!
  input: ToolCallInput!
  isSystemTool: Boolean!
  isAgentCall: Boolean!
}

type ToolStreamData {
  toolCallId: ID!
  chunk: String!
}

type ToolResultData {
  toolCallId: ID!
  output: String!
  success: Boolean!
  error: Error
}

type CompletionData {
  completion: AgentCompletion!
}

type InputRequestData {
  inputRequest: InputRequest!
}

type AgentCallStartData {
  parentStepId: ID!
  childStepId: ID!
  agentName: String!
  agentSource: AgentSource!
  input: String!
  callDepth: Int!
}

type AgentCallCompleteData {
  parentStepId: ID!
  childStepId: ID!
  agentName: String!
  completion: AgentCompletion!
}

# =============================================================================
# ANALYTICS TYPES
# =============================================================================

type SystemStats {
  totalRuns: Int!
  activeRuns: Int!
  totalAgents: Int!
  totalUsers: Int!
  totalCost: Float!
  averageRunDuration: Float!
  successRate: Float!
}

type AgentAnalytics {
  agentName: String!
  totalRuns: Int!
  successRate: Float!
  averageExecutionTime: Float!
  averageCost: Float!
  totalCost: Float!
  commonErrors: [ErrorFrequency!]!
  peakUsageHours: [Int!]!
  userSatisfactionScore: Float
}

type ErrorFrequency {
  error: Error!
  count: Int!
  percentage: Float!
}

type CostAnalytics {
  totalCost: Float!
  costByAgent: [AgentCostBreakdown!]!
  costByModel: [ModelCostBreakdown!]!
  costTrend: [CostDataPoint!]!
  projectedMonthlyCost: Float!
}

type AgentCostBreakdown {
  agentName: String!
  totalCost: Float!
  percentage: Float!
  runCount: Int!
  averageCostPerRun: Float!
}

type ModelCostBreakdown {
  model: String!
  provider: String!
  totalCost: Float!
  percentage: Float!
  tokenCount: Int!
}

type CostDataPoint {
  date: DateTime!
  totalCost: Float!
  runCount: Int!
}

# =============================================================================
# CONNECTION TYPES (Relay-style pagination)
# =============================================================================

type GitAgentConnection {
  edges: [GitAgentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type GitAgentEdge {
  node: Agent!
  cursor: String!
}

type StepConnection {
  edges: [StepEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type StepEdge {
  node: Step!
  cursor: String!
}

type RunConnection {
  edges: [RunEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type RunEdge {
  node: Run!
  cursor: String!
}

type ToolConnection {
  edges: [ToolEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ToolEdge {
  node: Tool!
  cursor: String!
}

type AgentConnection {
  edges: [AgentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AgentEdge {
  node: Agent!
  cursor: String!
}

# =============================================================================
# INPUT TYPES
# =============================================================================

input StepFilter {
  type: StepType
  status: ExecutionState
  agentName: String
}

input AgentFilter {
  source: AgentSource
  tags: [String!]
  repository: String
  isActive: Boolean
}

input RunFilter {
  status: ExecutionState
  createdBy: ID
  createdAfter: DateTime
  createdBefore: DateTime
  hasInputRequests: Boolean
}

input CreateUserInput {
  email: EmailAddress!
  name: String!
  role: UserRole!
}

input UpdateUserInput {
  name: String
  role: UserRole
  isActive: Boolean
}

input CreateRepositoryInput {
  name: String!
  gitUrl: String!
  branch: String!
  isRoot: Boolean!
  syncInterval: String
  authType: String!
  authToken: String
  sshKeyPath: String
}

input UpdateRepositoryInput {
  branch: String
  isRoot: Boolean
  syncInterval: String
  isActive: Boolean
}

input RegisterExternalAgentInput {
  name: String!
  description: String!
  endpoint: String!
  authType: String!
  authCredentials: AuthCredentialsInput!
}

input AuthCredentialsInput {
  apiKey: String
  bearerToken: String
  username: String
  password: String
  clientId: String
  clientSecret: String
}

input CreateMcpServerInput {
  name: String!
  description: String
  type: McpServerType!
  endpoint: String!
  authType: String
  authCredentials: AuthCredentialsInput
}

input ExecuteAgentInput {
  agentName: String!
  input: String!
  source: AgentSource
  contextScope: ContextScope
  gitCommit: String
}

input ProvideInputInput {
  inputRequestId: ID!
  response: String!
}

# =============================================================================
# QUERY ROOT
# =============================================================================

type Query {
  # Current user
  viewer: User
  
  # Users
  user(id: ID!): User
  users(first: Int, after: String): UserConnection!
  
  # Repositories
  repository(name: String!): AgentRepository
  repositories(first: Int, after: String): RepositoryConnection!
  
  # Agents
  agent(name: String!, source: AgentSource): Agent
  agents(
    first: Int
    after: String
    filter: AgentFilter
    search: String
  ): AgentConnection!
  
  # MCP Servers
  mcpServer(id: ID!): McpServer
  mcpServers(first: Int, after: String, type: McpServerType): McpServerConnection!
  
  # Tools
  tool(id: ID!): Tool
  systemTools: [Tool!]!
  
  # Runs & Execution
  run(id: ID!): Run
  runs(
    first: Int
    after: String
    filter: RunFilter
  ): RunConnection!
  
  # Analytics
  systemStats(timeRange: TimeRange!): SystemStats!
  agentAnalytics(agentName: String!, timeRange: TimeRange!): AgentAnalytics!
  costAnalytics(timeRange: TimeRange!): CostAnalytics!
}

# =============================================================================
# MUTATION ROOT
# =============================================================================

type Mutation {
  # Users
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!
  
  # Repositories
  createRepository(input: CreateRepositoryInput!): AgentRepository!
  updateRepository(name: String!, input: UpdateRepositoryInput!): AgentRepository!
  deleteRepository(name: String!): Boolean!
  syncRepository(name: String!): AgentRepository!
  syncAllRepositories: [AgentRepository!]!
  
  # External Agents
  registerExternalAgent(input: RegisterExternalAgentInput!): Agent!
  updateExternalAgent(name: String!, input: RegisterExternalAgentInput!): Agent!
  removeExternalAgent(name: String!): Boolean!
  
  # MCP Servers
  createMcpServer(input: CreateMcpServerInput!): McpServer!
  updateMcpServer(id: ID!, input: CreateMcpServerInput!): McpServer!
  deleteMcpServer(id: ID!): Boolean!
  
  # Execution
  executeAgent(input: ExecuteAgentInput!): Run!
  cancelRun(id: ID!): Run!
  provideInput(runId: ID!, input: ProvideInputInput!): Run!
  
  # System
  clearCache: Boolean!
}

# =============================================================================
# SUBSCRIPTION ROOT
# =============================================================================

type Subscription {
  # Execution updates
  runUpdated(runId: ID!): Run!
  stepStream(stepId: ID!): StreamEvent!
  
  # Input requests
  inputRequested(runId: ID): InputRequest!
  
  # Repository updates
  repositorySynced: AgentRepository!
  
  # System events
  systemAlert: SystemAlert!
}

# =============================================================================
# ADDITIONAL TYPES
# =============================================================================

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  node: User!
  cursor: String!
}

type RepositoryConnection {
  edges: [RepositoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type RepositoryEdge {
  node: AgentRepository!
  cursor: String!
}

type McpServerConnection {
  edges: [McpServerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type McpServerEdge {
  node: McpServer!
  cursor: String!
}

input TimeRange {
  start: DateTime!
  end: DateTime!
}

type SystemAlert {
  id: ID!
  type: String!
  severity: String!
  message: String!
  timestamp: DateTime!
  metadata: [MetadataField!]
}